<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初学者的嵌入式 Linux 计划！</title>
      <link href="/posts/2197848538/"/>
      <url>/posts/2197848538/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>俗话说万事开头难，刚开始的时候，你是否根本就不知如何开始，上网查资料被一堆堆新名词搞的找不到北，去图书馆看书也是找不到方向?又是arm，又是linux，又是uboot头都大了，不知道自己究竟从哪里开始？</p><p>简单说，从arm基础知识到裸机编程，从uCOSII到linux，从linux基础的命令到shell编程，从u-boot到文件系统，最后到现在的linux驱动程序。从简单到复杂，从基础到高级基本是按照这个来的。</p><h3 id="第一阶段：嵌入式硬件基础以及裸机程序开发"><a href="#第一阶段：嵌入式硬件基础以及裸机程序开发" class="headerlink" title="第一阶段：嵌入式硬件基础以及裸机程序开发"></a><strong>第一阶段：嵌入式硬件基础以及裸机程序开发</strong></h3><p><strong>1.知识点：</strong></p><p>（1） arm处理器基础知识，工作模式，寄存器，中断与异常，寻址方式，汇编指令集</p><p>（2） 熟悉ADS集成开发环境为裸机程序开发做准备</p><p>（3）裸机程序开发：LED，串口，LCD，触摸屏，NANDFLASH，IIC，IIS，DMA等</p><p><strong>2.过程以及目的：</strong></p><p>这一阶段的学习主要是熟悉嵌入式的硬件，为以后的linux驱动打基础。因为嵌入式主打处理器架构就是arm,所以针对arm来学习。首先学习基础知识，然后通过在开发板上的练习来掌握。这一阶段所用的资料主要有：</p><p>（1） 《ARM嵌入式基础教程》 这本书主要看arm基础的知识。这本书是讲arm7的，但是arm的基础的指令集以及模型是一样的。</p><p>（2） 《嵌入式linux应用开发完全手册》 这本书主要看介绍s3c2410接口模块的部分，实验裸机的时候需要硬件的知识。</p><p><strong>3.所用时间：</strong>大约两个月。</p><h3 id="第二阶段：linux基础以及shell编程"><a href="#第二阶段：linux基础以及shell编程" class="headerlink" title="第二阶段：linux基础以及shell编程"></a><strong>第二阶段：linux基础以及shell编程</strong></h3><p><strong>1.知识点：</strong></p><p>（1） linux基础知识</p><p>（2） linux安装与使用</p><p>（3） linux常用命令</p><p>（4） vi使用</p><p>（5） 简单shell编程</p><p><strong>2.过程以及目的：</strong>  </p><p>这一阶段的学习主要是熟悉linux，会安装linux，了解Linux的基础知识，会简单的操作。刚开始安装linux还是在虚拟机上安装比较好,安装开发板推荐的Fedora9，按照开发板配套的说明一步一步的安装，然后在上面练习各种命令。</p><p>这一阶段主要要看《鸟哥的linux私房菜基础学习篇》，这个书有电子版，也不用全看，主要是看前面对Linux基础知识的描述，以及基本的命令。命令只是了解，那么多记也记不下来，以后用时再查阅。这一阶段主要目的是对linux有一个整体的了解，最起码要知道基础的一些概念，还有会一些基本的操作。</p><p><strong>3.时间：</strong>大约一个月。</p><h3 id="第三阶段：linux应用程序基础开发"><a href="#第三阶段：linux应用程序基础开发" class="headerlink" title="第三阶段：linux应用程序基础开发"></a><strong>第三阶段：linux应用程序基础开发</strong></h3><p><strong>1.知识点：</strong></p><p>  （1） GCC，GDB，Make 基础</p><p>  （2） 文件，时间编程</p><p>  （3） 多进程，多线程程序设计</p><p>  （4） 进程间通信</p><p><strong>2. 过程以及目的：</strong></p><p>这一阶段的学习主要是了解linux应用程序的编写调试，也都是基础知识，主要目的还是熟悉Linux。熟悉其中应用程序有关的一些概念，为以后打基础。这一阶段主要看了《嵌入式Linux应用程序开发标准教程》，这本书对linux上应用程序编写讲的很详细，而且不是很难，那本最经典的《UNIX高级环境编程》讲的比较深入，刚开始看有点难，万事开头难还是从简单的开始。学习应用编程以后也不一定搞应用，从事嵌入式linux行业的人，这是必须的基本技能。</p><p><strong>3. 时间：</strong>大约一个月</p><h3 id="第四阶段：uCOSII操作系统学习"><a href="#第四阶段：uCOSII操作系统学习" class="headerlink" title="第四阶段：uCOSII操作系统学习"></a><strong>第四阶段：uCOSII操作系统学习</strong></h3><p><strong>1.知识点：</strong></p><p>  （1）嵌入式实时操作系统的概念以及基础知识</p><p>  （2）uCOSII操作系统源代码阅读</p><p>  （3）移植uCOSII</p><p>  （4）uCOSII操作系统应用编程</p><p><strong>2.过程以及目的：</strong></p><p>这一阶段的学习主要是了解嵌入式实时操作系统的基础，因为uCOSII是开源的，可以研究他的代码。对操作系统的任务调度以及资源管理有直观的认识。并且阅读他的源码能够提高自己的编程能力，规范自己的编程习惯。虽然提供了uCOSII的移植版本，但是自己实际移植一次能够有更深刻的认识。</p><p>这个操作系统比较简单，所以应用程序的编写就很重要，在上面实现几个功能还是有助于对系统的理解。这一阶段主要看的就是邵贝贝翻译的uCOSII作者所著的《嵌入式实时操作系统uCOS-II》,里面对操作系统的源码有详细的分析。看透这本书后就会对uCOSII有一个深入的了解。这一阶段的主要目的是了解操作系统的知识，比如任务调度，并发与竞态。还有一个目的就是锻炼自己的编程能力。因为如果看介绍操作系统原理的书会比较枯燥，我感觉阅读一个操作系统的源码比看一千本介绍原理的书来的实惠的多。</p><p><strong>3.时间：</strong>大约一个月</p><h3 id="第五阶段：bootloader学习"><a href="#第五阶段：bootloader学习" class="headerlink" title="第五阶段：bootloader学习"></a><strong>第五阶段：bootloader学习</strong></h3><p><strong>1.知识点：</strong></p><p>  （1）bootloader基础知识</p><p>  （2）u-boot基础与命令</p><p>  （3）u-boot移植</p><p><strong>2.过程以及目的：</strong><br>bootloader是一个linux嵌入式系统的不可缺少的部分。这一阶段的学习主要是了解bootloader的作用，以及通用bootloader—u-boot的知识，刚开始学会用u-boot的各种命令。然后分析u-boot的启动流程和Makefile以及u-boot加载内核过程。然后按照别人的步骤一步一步的移植内核，多做几遍以熟悉这个过程。然后在熟悉整个u-boot的基础上，独自完成u-boot的移植，并添加自己修改。这一阶段主要参考资料就是光盘自带的u-boot移植参考手册和一些网络上的文章。个人感觉u-boot移植这方面的网络资源相当的丰富。</p><p><strong>3.时间：</strong>大约一个月</p><h3 id="第六阶段：文件系统学习"><a href="#第六阶段：文件系统学习" class="headerlink" title="第六阶段：文件系统学习"></a><strong>第六阶段：文件系统学习</strong></h3><p><strong>1.知识点：</strong></p><p>  （1）linux文件系统的种类与作用</p><p>  （2）熟悉busybox的使用，以及linux系统启动过程</p><p>  （3）构建自己的根文件系统</p><p><strong>2.过程以及目的:</strong><br>文件系统也是一个linux嵌入式系统不可缺少的部分，这一阶段的学习主要是熟悉根文件系统的作用以及基础知识，并且自己构建自己的根文件系统。这一阶段所看的书有《构建嵌入式linux系统》，这本书详细讲解了嵌入式linux的所有元素，包括文件系统。这里主要看文件系统这块。我还参考了网上的一些文章。这里首先要熟悉基本的一些Linux文件系统,然后学习busybox的使用以及linux的启动过程，最后参考别人的一步一步来构建自己的文件系统。</p><p><strong>3.时间：</strong>大约半个月</p><h3 id="第七阶段：嵌入式图形界面GUI"><a href="#第七阶段：嵌入式图形界面GUI" class="headerlink" title="第七阶段：嵌入式图形界面GUI"></a><strong>第七阶段：嵌入式图形界面GUI</strong></h3><p><strong>1.知识点：</strong></p><p> （1）嵌入式图形界面GUI的种类与特点</p><p>  （2）minigui 基础知识</p><p>  （3）minigui 移植与程序编写</p><p><strong>2.过程以及目的：</strong><br>嵌入式图形界面GUI作为嵌入式上层系统的东西也是需要了解的，这里我只学习了minigui，因为QT是需要C++的知识，而我没有学过C++，所以只看了minigui的相关知识。这个阶段的目的主要是熟悉一下嵌入式图形接界面的开发流程，因为以后也不打算搞应用。</p><p>只是熟悉一下嵌入式组成的一些方面。这里只要将minigui移植到板子上能跑hello程序就可以了。其他的也不用深入了解。通过移植minigui对linux上运行的软件以及函数库，程序运行原理，编译器都会有一个新的认识。</p><p><strong>3 时间：</strong>大约半个月</p><h3 id="第八阶段：linux驱动程序基础知识"><a href="#第八阶段：linux驱动程序基础知识" class="headerlink" title="第八阶段：linux驱动程序基础知识"></a><strong>第八阶段：linux驱动程序基础知识</strong></h3><p><strong>1.知识点：</strong></p><p>（1）看完《LINUX设备驱动程序》除了网络驱动程序，tty驱动程序，块驱动程序这几章不看，其他的都要看完。</p><p>（2）实验书中所有例程，要仔细分析结果，理解相关知识点。</p><p>（3）就算是例子，程序编程习惯一定要统一，文档一定要规范。</p><p><strong>2.过程以及目的</strong></p><p>这一阶段的目的就是为了linux驱动打基础，《LINUX设备驱动程序》（第三版）也就是大家所说的ldd3，是最经典的一本讲linux驱动的书，一定要看而且多看几遍。第一次看很难看进去，感觉讲的晦涩难懂。但是多看几遍就会由豁然开朗的感觉。看完了书，然后就是实验书中的例子。</p><p>﻿<strong>3.时间：</strong>大约两个月</p><h3 id="第九阶段：linux驱动实战"><a href="#第九阶段：linux驱动实战" class="headerlink" title="第九阶段：linux驱动实战"></a><strong>第九阶段：linux驱动实战</strong></h3><p><strong>1. 知识点：</strong></p><p>  （1）通过led驱动理解杂项字符设备的注册与实现，并掌握MINI2440的IO操作过程。</p><p>  （2）通过button驱动程序掌握基本的中断实现方法。</p><p>  （3）掌握PWM驱动程序。</p><p>  （4）通过触摸屏驱动程序掌握input设备模型的实现。</p><p>  （5）掌握ADC驱动程序的设计</p><p>  （6）掌握看门狗,rtc驱动程序的设计</p><p>  （7）通过LCD驱动程序分析platform设备模型的实现。</p><p><strong>2.过程以及目的：</strong><br>这一阶段的学习主要是掌握实际的简单的驱动程序的实现与ldd3中的差别，并且分析一些linux子系统。通过这一阶段的学习，能够对linux驱动程序有更深入的认识。并且锻炼自己阅读海量代码的能力。这一阶段主要工作就是看代码，实验，看代码，实验，通过现象学习知识。</p><p><strong>3. 时间：</strong>大约一个月</p><h3 id="第十阶段：深入理解linux内核与USB子系统的研究"><a href="#第十阶段：深入理解linux内核与USB子系统的研究" class="headerlink" title="第十阶段：深入理解linux内核与USB子系统的研究"></a><strong>第十阶段：深入理解linux内核与USB子系统的研究</strong></h3><p>‌前九个阶段完成了，自己感觉嵌入式Linux应该应该算是入门了。所以要开始计划第十个阶段了。这一阶段基本上要确定自己未来的发展方向了。因为现在嵌入式系统的标准接口都有USB，所以学会USB的相关知识是很有竞争力的。搞驱动的人对内核应该有一定的了解，所以《深入理解Linux内核》还是必须的。</p><p>这一阶段主要是学习USB协议，阅读linux USB子系统全部的代码，通过阅读代码加深对USB的理解，随后就是熟悉各种USB类协议，编写和移植USB驱动了。USB是我确定的方向，因为我想搞什么东西都要专一，什么都搞，什么也搞不好。所以我决定学习USB。决定以后从事嵌入式有关USB方面的工作。这一阶段的学习正在进行中，现在正在linux USB子系统浩瀚的代码中漫游。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/posts/593668330/"/>
      <url>/posts/593668330/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><blockquote><p>说真的，任何说起嵌入式软件怎么入门啊？需要学些什么东西啊，我差不多一致的回答都是：软件方面C语言和数据结构加上一些简单常用的算法，这些需要学好。</p></blockquote><blockquote><p>借着自己的回顾学习，我也写一些基础的数据结构知识，多画图，少BB，与大家一起学习数据结构</p></blockquote><h2 id="顺序存储和链式存储"><a href="#顺序存储和链式存储" class="headerlink" title="顺序存储和链式存储"></a>顺序存储和链式存储</h2><h3 id="数组—顺序存储"><a href="#数组—顺序存储" class="headerlink" title="数组—顺序存储"></a>数组—顺序存储</h3><p>数组作为一个顺序储存方式的数据结构，可是有大作为的，它的灵活使用为我们的程序设计带来了大量的便利；</p><p>但是，但是，数组最大的缺点就是我们的插入和删除时需要移动大量的元素，所以呢，大量的消耗时间，以及冗余度难以接受了。</p><p>以C语言数组插入一个元素为例，当我们需要在一个数组<code>{1,2,3,4}</code>的第1个元素后的位置插入一个’A’时，我们需要做的有：</p><ol><li>将第1个元素后的整体元素后移，形成新的数组<code>{1,2,2,3,4}</code></li><li>再将第2个元素位置的元素替换为我们所需要的元素’A’</li><li>最终形成我们的预期，这需要很多的操作喔。</li></ol><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080152.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080152.png" class="lazyload" title></a></p><p>上图可以看出，使用数组都有这两大缺点：</p><ol><li>插入删除操作所需要移动的元素很多，浪费算力。</li><li>必须为数组开足够的空间，否则有溢出风险。</li></ol><h3 id="链表—链式存储"><a href="#链表—链式存储" class="headerlink" title="链表—链式存储"></a>链表—链式存储</h3><p>由于数组的这些缺点，自然而然的就产生链表的思想了。</p><p>链表通过不连续的储存方式，自适应内存大小，以及指针的灵活使用，巧妙的简化了上述的内容。</p><p>链表的基本思维是，利用结构体的设置，额外开辟出一份内存空间去作指针，它总是指向下一个结点，一个个结点通过NEXT指针相互串联，就形成了链表。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080254.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080254.png" class="lazyload" title></a></p><p>其中DATA为自定义的数据类型，NEXT为指向下一个链表结点的指针，通过访问NEXT，可以引导我们去访问链表的下一个结点。</p><p>对于一连串的结点而言，就形成了链表如下图：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080330.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080330.png" class="lazyload" title></a></p><p>上文所说的插入删除操作只需要修改指针所指向的区域就可以了，不需要进行大量的数据移动操作。如下图：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080358.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080358.png" class="lazyload" title></a></p><p>相比起数组，链表解决了数组不方便移动，插入，删除元素的弊端，但相应的，链表付出了更加大的内存牺牲换来的这些功能的实现。</p><h2 id="链表概述"><a href="#链表概述" class="headerlink" title="链表概述"></a>链表概述</h2><p>包含单链表，双链表，循环单链表，实际应用中的功能不同，但实现方式都差不多。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080442.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080442.png" class="lazyload" title></a></p><ul><li><strong>单链表</strong>就像是美国男篮，一代一代往下传；</li><li><strong>双链表</strong>像是中国男足，你传球给我，我传球给你，最终传给了守门员；</li><li><strong>循环链表</strong>就像是中国男篮，火炬从姚明传给王治郅，王治郅传给易建联，现在易建联伤了，又传给了姚明</li></ul><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表概念和简单的设计"><a href="#单链表概念和简单的设计" class="headerlink" title="单链表概念和简单的设计"></a>单链表概念和简单的设计</h3><p>单链表是一种链式存取的数据结构，链表中的数据是以结点来表示的，每个结点由元素和指针构成。</p><p>元素表示数据元素的映象，就是存储数据的存储单元；指针指示出后继元素存储位置，就是连接每个结点的地址数据。</p><p>以<code>结点的序列</code>表示的线性表称作线性链表，也就是单链表，单链表是链式存取的结构。</p><p>对于链表的每一个结点，我们使用结构体进行设计，其主要内容有：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080254.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080254.png" class="lazyload" title></a></p><p>其中，DATA数据元素，可以为你想要储存的任何数据格式，可以是数组，可以是int，甚至可以是结构体（这就是传说中的结构体套结构体）</p><p>NEXT为一个指针，其代表了一个可以指向的区域，通常是用来指向下一个结点，链表的尾部NEXT指向NULL（空），因为尾部没有任何可以指向的空间了</p><p>故，对于一个单链表的结点定义，可以代码描述成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义结点类型</span><br><span class="line">typedef struct Node {</span><br><span class="line">    int data;       //数据类型，你可以把int型的data换成任意数据类型，包括结构体struct等复合类型</span><br><span class="line">    struct Node *next;          //单链表的指针域</span><br><span class="line">} Node,*LinkedList;  </span><br><span class="line">//Node表示结点的类型，LinkedList表示指向Node结点类型的指针类型</span><br></pre></td></tr></tbody></table></figure></div><h3 id="链表的初始化"><a href="#链表的初始化" class="headerlink" title="链表的初始化"></a>链表的初始化</h3><p>初始化主要完成以下工作：创建一个单链表的前置节点并向后逐步添加节点，一般指的是申请结点的空间，同时对一个结点赋空值(NULL)，其代码可以表示为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedList listinit(){</span><br><span class="line">    Node *L;</span><br><span class="line">    L=(Node*)malloc(sizeof(Node));      //开辟空间 </span><br><span class="line">    if(L==NULL){                     //判断是否开辟空间失败，这一步很有必要</span><br><span class="line">        printf("申请空间失败");</span><br><span class="line">        //exit(0);                  //开辟空间失败可以考虑直接结束程序</span><br><span class="line">    }</span><br><span class="line">    L->next=NULL;       //指针指向空</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>注意：</strong>一定要判断是否开辟空间失败，否则生产中由于未知的情况造成空间开辟失败，仍然在继续执行代码，后果将不堪设想啦，因此养成这样的判断是很有必要的。</p><h3 id="头插入法创建单链表"><a href="#头插入法创建单链表" class="headerlink" title="头插入法创建单链表"></a>头插入法创建单链表</h3><p>利用指针指向下一个结点元素的方式进行逐个创建，使用头插入法最终得到的结果是逆序的。如图所示：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080559.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080559.png" class="lazyload" title></a></p><p>从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//头插法建立单链表</span><br><span class="line">LinkedList LinkedListCreatH() {</span><br><span class="line">    Node *L;</span><br><span class="line">    L = (Node *)malloc(sizeof(Node));   //申请头结点空间</span><br><span class="line">    L->next = NULL;                      //初始化一个空链表</span><br><span class="line">  </span><br><span class="line">    int x;                         //x为链表数据域中的数据</span><br><span class="line">    while(scanf("%d",&x) != EOF) {</span><br><span class="line">        Node *p;</span><br><span class="line">        p = (Node *)malloc(sizeof(Node));   //申请新的结点</span><br><span class="line">        p->data = x;                     //结点数据域赋值</span><br><span class="line">        p->next = L->next;     //将结点插入到表头L-->|2|-->|1|-->NULL</span><br><span class="line">        L->next = p;</span><br><span class="line">    }</span><br><span class="line">    return L;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="尾插入法创建单链表"><a href="#尾插入法创建单链表" class="headerlink" title="尾插入法创建单链表"></a>尾插入法创建单链表</h3><p>如图所示为尾插入法的创建过程。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080628.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080628.png" class="lazyload" title></a></p><p>头插法生成的链表中，结点的次序和输入数据的顺序不一致。若希望两者次序一致，则需要尾插法。</p><p>该方法是将新结点逐个插入到当前链表的表尾上，为此必须增加一个尾指针r, 使其始终指向当前链表的尾结点，代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//尾插法建立单链表</span><br><span class="line">  </span><br><span class="line">LinkedList LinkedListCreatT() {</span><br><span class="line">    Node *L;</span><br><span class="line">    L = (Node *)malloc(sizeof(Node));   //申请头结点空间</span><br><span class="line">    L->next = NULL;                  //初始化一个空链表</span><br><span class="line">    Node *r;</span><br><span class="line">    r = L;                          //r始终指向终端结点，开始时指向头结点</span><br><span class="line">    int x;                         //x为链表数据域中的数据</span><br><span class="line">    while(scanf("%d",&x) != EOF) {</span><br><span class="line">        Node *p;</span><br><span class="line">        p = (Node *)malloc(sizeof(Node));   //申请新的结点</span><br><span class="line">        p->data = x;                     //结点数据域赋值</span><br><span class="line">        r->next = p;            //将结点插入到表头L-->|1|-->|2|-->NULL</span><br><span class="line">        r = p;</span><br><span class="line">    }</span><br><span class="line">    r->next = NULL;</span><br><span class="line">    return L;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="遍历单链表如打印、修改"><a href="#遍历单链表如打印、修改" class="headerlink" title="遍历单链表如打印、修改"></a>遍历单链表如打印、修改</h3><p>从链表的头开始，逐步向后进行每一个元素的访问，称为遍历。</p><p>对于遍历操作，我们可以衍生出很多常用的数据操作，比如查询元素，修改元素，获取元素个数，打印整个链表数据等等。</p><p>进行遍历的思路极其简单，只需要建立一个指向链表L的结点，然后沿着链表L逐个向后搜索即可，代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//便利输出单链表</span><br><span class="line">void printList(LinkedList L){</span><br><span class="line">    Node *p=L->next;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(p){</span><br><span class="line">        printf("第%d个元素的值为:%d\n",++i,p->data);</span><br><span class="line">        p=p->next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>对于元素修改操作，以下是代码实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//链表内容的修改，在链表中修改值为x的元素变为为k。</span><br><span class="line">LinkedList LinkedListReplace(LinkedList L,int x,int k) {</span><br><span class="line">    Node *p=L->next;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(p){</span><br><span class="line">        if(p->data==x){</span><br><span class="line">            p->data=k;</span><br><span class="line">        }</span><br><span class="line">        p=p->next;</span><br><span class="line">    }</span><br><span class="line">    return L;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>简单的遍历设计的函数只需要void无参即可，而当涉及到元素操作时，可以设计一个LinkedList类型的函数，使其返回一个操作后的新链表。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>链表的插入操作主要分为查找到第i个位置，将该位置的next指针修改为指向我们新插入的结点，而新插入的结点next指针指向我们i+1个位置的结点。</p><p>其操作方式可以设置一个前驱结点，利用循环找到第i个位置，再进行插入。</p><p>如图，在DATA1和DATA2数据结点之中插入一个NEW_DATA数据结点：</p><p>从原来的链表状态</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080330.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080330.png" class="lazyload" title></a></p><p>到新的链表状态：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080358.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080358.png" class="lazyload" title></a></p><p>代码实现如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//单链表的插入，在链表的第i个位置插入x的元素</span><br><span class="line">  </span><br><span class="line">LinkedList LinkedListInsert(LinkedList L,int i,int x) {</span><br><span class="line">    Node *pre;                      //pre为前驱结点</span><br><span class="line">    pre = L;</span><br><span class="line">    int tempi = 0;</span><br><span class="line">    for (tempi = 1; tempi < i; tempi++) {</span><br><span class="line">        pre = pre->next;                 //查找第i个位置的前驱结点</span><br><span class="line">    }</span><br><span class="line">    Node *p;                                //插入的结点为p</span><br><span class="line">    p = (Node *)malloc(sizeof(Node));</span><br><span class="line">    p->data = x;</span><br><span class="line">    p->next = pre->next;</span><br><span class="line">    pre->next = p;</span><br><span class="line">  </span><br><span class="line">    return L;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除元素要建立一个前驱结点和一个当前结点，当找到了我们需要删除的数据时，直接使用前驱结点跳过要删除的结点指向要删除结点的后一个结点，再将原有的结点通过free函数释放掉。如图所示：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080814.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080814.png" class="lazyload" title></a></p><p>代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//单链表的删除，在链表中删除值为x的元素</span><br><span class="line">  </span><br><span class="line">LinkedList LinkedListDelete(LinkedList L,int x) {</span><br><span class="line">    Node *p,*pre;                   //pre为前驱结点，p为查找的结点。</span><br><span class="line">    p = L->next;</span><br><span class="line">     </span><br><span class="line">    while(p->data != x) {              //查找值为x的元素</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p->next;</span><br><span class="line">    }</span><br><span class="line">    pre->next = p->next;          //删除操作，将其前驱next指向其后继。</span><br><span class="line">    free(p);</span><br><span class="line">     </span><br><span class="line">    return L;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="双向链表的简介以及概念"><a href="#双向链表的简介以及概念" class="headerlink" title="双向链表的简介以及概念"></a>双向链表的简介以及概念</h3><p>单链表是指结点中只有一个指向其后继的指针，具有单向性，但是有时需要搜索大量数据的时候，就需要多次进行从头开始的遍历，这样的搜索就不是很高效了。</p><p>在单链表的基础上，对于每一个结点设计一个前驱结点，前驱结点与前一个结点相互连接，构成一个链表，就产生了双向链表的概念了。</p><p>双向链表可以简称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080853.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080853.png" class="lazyload" title></a>双向链表示意图</p><p>一个完整的双向链表应该是头结点的pre指针指为空，尾结点的next指针指向空，其余结点前后相链。</p><h3 id="双向链表的结点设计"><a href="#双向链表的结点设计" class="headerlink" title="双向链表的结点设计"></a>双向链表的结点设计</h3><p>对于每一个结点而言，有：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080921.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019080921.png" class="lazyload" title></a></p><p>其中，DATA表示数据，其可以是简单的类型也可以是复杂的结构体；</p><p>pre代表的是前驱指针，它总是指向当前结点的前一个结点，如果当前结点是头结点，则pre指针为空；</p><p>next代表的是后继指针，它总是指向当前结点的下一个结点，如果当前结点是尾结点，则next指针为空</p><p>其代码设计如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct line{</span><br><span class="line">    int data;           //data</span><br><span class="line">    struct line *pre;   //pre node</span><br><span class="line">    struct line *next;  //next node</span><br><span class="line">}line,*a;</span><br><span class="line">//分别表示该结点的前驱(pre)，后继(next)，以及当前数据(data)</span><br></pre></td></tr></tbody></table></figure></div><ol><li>双链表的创建</li></ol><p>创建双向链表需要先创建头结点，然后逐步的进行添加双向链表的头结点是有数据元素的，也就是头结点的data域中是存有数据的，这与一般的单链表是不同的。</p><p>对于逐步添加数据，先开辟一段新的内存空间作为新的结点，为这个结点进行的data进行赋值，然后将已成链表的上一个结点的next指针指向自身，自身的pre指针指向上一个结点。</p><p>其代码可以设计为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//创建双链表</span><br><span class="line">line* initLine(line * head){</span><br><span class="line">    int number,pos=1,input_data;</span><br><span class="line">    //三个变量分别代表结点数量，当前位置，输入的数据</span><br><span class="line">    printf("请输入创建结点的大小\n");</span><br><span class="line">    scanf("%d",&number);</span><br><span class="line">    if(number<1){return NULL;} //输入非法直接结束</span><br><span class="line">    //////头结点创建///////</span><br><span class="line">    head=(line*)malloc(sizeof(line));</span><br><span class="line">    head->pre=NULL;</span><br><span class="line">    head->next=NULL;</span><br><span class="line">    printf("输入第%d个数据\n",pos++);</span><br><span class="line">    scanf("%d",&input_data);</span><br><span class="line">    head->data=input_data;</span><br><span class="line">  </span><br><span class="line">    line * list=head;</span><br><span class="line">    while (pos<=number) {</span><br><span class="line">        line * body=(line*)malloc(sizeof(line));</span><br><span class="line">        body->pre=NULL;</span><br><span class="line">        body->next=NULL;</span><br><span class="line">        printf("输入第%d个数据\n",pos++);</span><br><span class="line">        scanf("%d",&input_data);</span><br><span class="line">        body->data=input_data;</span><br><span class="line">        </span><br><span class="line">        list->next=body;</span><br><span class="line">        body->pre=list;</span><br><span class="line">        list=list->next;</span><br><span class="line">    }</span><br><span class="line">    return head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>双向链表创建的过程可以分为：创建头结点->创建一个新的结点->将头结点和新结点相互链接->再度创建新结点，这样会有助于理解。</p><h3 id="双向链表的插入操作"><a href="#双向链表的插入操作" class="headerlink" title="双向链表的插入操作"></a>双向链表的插入操作</h3><p>如图所示：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081001.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081001.png" class="lazyload" title></a></p><p>对于每一次的双向链表的插入操作，首先需要创建一个独立的结点，并通过malloc操作开辟相应的空间；</p><p>其次我们选中这个新创建的独立节点，将其的pre指针指向所需插入位置的前一个结点；</p><p>同时，其所需插入的前一个结点的next指针修改指向为该新的结点，该新的结点的next指针将会指向一个原本的下一个结点，而修改下一个结点的pre指针为指向新结点自身，这样的一个操作我们称之为双向链表的插入操作。</p><p>其代码可以表示为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//插入数据</span><br><span class="line">line * insertLine(line * head,int data,int add){</span><br><span class="line">    //三个参数分别为：进行此操作的双链表，插入的数据，插入的位置</span><br><span class="line">    //新建数据域为data的结点</span><br><span class="line">    line * temp=(line*)malloc(sizeof(line));</span><br><span class="line">    temp->data=data;</span><br><span class="line">    temp->pre=NULL;</span><br><span class="line">    temp->next=NULL;</span><br><span class="line">    //插入到链表头，要特殊考虑</span><br><span class="line">    if (add==1) {</span><br><span class="line">        temp->next=head;</span><br><span class="line">        head->pre=temp;</span><br><span class="line">        head=temp;</span><br><span class="line">    }else{</span><br><span class="line">        line * body=head;</span><br><span class="line">        //找到要插入位置的前一个结点</span><br><span class="line">        for (int i=1; i<add-1; i++) {< span><br><span class="line">            body=body->next;</span><br><span class="line">        }</span><br><span class="line">        //判断条件为真，说明插入位置为链表尾</span><br><span class="line">        if (body->next==NULL) {</span><br><span class="line">            body->next=temp;</span><br><span class="line">            temp->pre=body;</span><br><span class="line">        }else{</span><br><span class="line">            body->next->pre=temp;</span><br><span class="line">            temp->next=body->next;</span><br><span class="line">            body->next=temp;</span><br><span class="line">            temp->pre=body;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return head;</span><br><span class="line">}</span><br></add-1;></span></pre></td></tr></tbody></table></figure></div><h3 id="双向链表的删除操作"><a href="#双向链表的删除操作" class="headerlink" title="双向链表的删除操作"></a>双向链表的删除操作</h3><p>如图：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081038.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081038.png" class="lazyload" title></a></p><p>删除操作的过程是：选择需要删除的结点->选中这个结点的前一个结点->将前一个结点的next指针指向自己的下一个结点->选中该节点的下一个结点->将下一个结点的pre指针修改指向为自己的上一个结点。</p><p>在进行遍历的时候直接将这一个结点给跳过了，之后，我们释放删除结点，归还空间给内存，这样的操作我们称之为双链表的删除操作。</p><p>其代码可以表示为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//删除元素</span><br><span class="line">line * deleteLine(line * head,int data){</span><br><span class="line">    //输入的参数分别为进行此操作的双链表，需要删除的数据</span><br><span class="line">    line * list=head;</span><br><span class="line">    //遍历链表</span><br><span class="line">    while (list) {</span><br><span class="line">        //判断是否与此元素相等</span><br><span class="line">        //删除该点方法为将该结点前一结点的next指向该节点后一结点</span><br><span class="line">        //同时将该结点的后一结点的pre指向该节点的前一结点</span><br><span class="line">        if (list->data==data) {</span><br><span class="line">            list->pre->next=list->next;</span><br><span class="line">            list->next->pre=list->pre;</span><br><span class="line">            free(list);</span><br><span class="line">            printf("--删除成功--\n");</span><br><span class="line">            return head;</span><br><span class="line">        }</span><br><span class="line">        list=list->next;</span><br><span class="line">    }</span><br><span class="line">    printf("Error:没有找到该元素，没有产生删除\n");</span><br><span class="line">    return head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="双向链表的遍历"><a href="#双向链表的遍历" class="headerlink" title="双向链表的遍历"></a>双向链表的遍历</h3><p>双向链表的遍历利用next指针逐步向后进行索引即可。</p><p>注意，在判断这里，我们既可以用while(list)的操作直接判断是否链表为空，也可以使用while(list->next)的操作判断该链表是否为空，其下一节点为空和本结点是否为空的判断条件是一样的效果。</p><p>其简单的代码可以表示为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//遍历双链表,同时打印元素数据</span><br><span class="line">void printLine(line *head){</span><br><span class="line">    line *list = head;</span><br><span class="line">    int pos=1;</span><br><span class="line">    while(list){</span><br><span class="line">        printf("第%d个数据是:%d\n",pos++,list->data);</span><br><span class="line">        list=list->next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="循环链表概念"><a href="#循环链表概念" class="headerlink" title="循环链表概念"></a>循环链表概念</h3><p>对于单链表以及双向链表，就像一个小巷，无论怎么走最终都能从一端走到另一端，顾名思义，循环链表则像一个有传送门的小巷，当你以为你走到结尾的时候，其实这就是开头。</p><p>循环链表和非循环链表其实创建的过程唯一不同的是，非循环链表的尾结点指向空（NULL），而循环链表的尾指针指向的是链表的开头。</p><p>通过将单链表的尾结点指向头结点的链表称之为循环单链表（Circular linkedlist）</p><p>一个完整的循环单链表如图：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081109.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081109.png" class="lazyload" title></a></p><h3 id="循环链表结点设计（以单循环链表为例）"><a href="#循环链表结点设计（以单循环链表为例）" class="headerlink" title="循环链表结点设计（以单循环链表为例）"></a>循环链表结点设计（以单循环链表为例）</h3><p>对于循环单链表的结点，可以完全参照于单链表的结点设计，如图：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081150.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081150.png" class="lazyload" title></a>单向循环链表结点</p><p>data表示数据；</p><p>next表示指针，它总是指向自身的下一个结点，对于只有一个结点的存在，这个next指针则永远指向自身，对于一个链表的尾部结点，next永远指向开头。</p><p>其代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list{</span><br><span class="line">    int data;</span><br><span class="line">    struct list *next;</span><br><span class="line">}list;</span><br><span class="line">//data为存储的数据，next指针为指向下一个结点</span><br></pre></td></tr></tbody></table></figure></div><h3 id="循环单链表初始化"><a href="#循环单链表初始化" class="headerlink" title="循环单链表初始化"></a>循环单链表初始化</h3><p>先创建一个头结点并且给其开辟内存空间，在开辟内存空间成功之后，将头结点的next指向head自身，创建一个init函数来完成；</p><p>为了重复创建和插入，我们可以在init函数重新创建的结点next指向空，而在主函数调用创建之后，将head头结点的next指针指向自身。</p><p>这样的操作方式可以方便过后的创建单链表，直接利用多次调用的插入函数即可完成整体创建。</p><p>其代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//初始结点</span><br><span class="line">list *initlist(){</span><br><span class="line">    list *head=(list*)malloc(sizeof(list));</span><br><span class="line">    if(head==NULL){</span><br><span class="line">        printf("创建失败，退出程序");</span><br><span class="line">        exit(0);</span><br><span class="line">    }else{</span><br><span class="line">        head->next=NULL;</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在主函数重调用可以是这样</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//////////初始化头结点//////////////</span><br><span class="line">list *head=initlist();</span><br><span class="line">head->next=head;</span><br></pre></td></tr></tbody></table></figure></div><h3 id="循环链表的创建操作"><a href="#循环链表的创建操作" class="headerlink" title="循环链表的创建操作"></a>循环链表的创建操作</h3><p>如图所示：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081358.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081358.png" class="lazyload" title></a>单向循环链表的创建</p><p>通过逐步的插入操作，创建一个新的节点，将原有链表尾结点的next指针修改指向到新的结点，新的结点的next指针再重新指向头部结点，然后逐步进行这样的插入操作，最终完成整个单项循环链表的创建。</p><p>其代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//创建——插入数据</span><br><span class="line">int insert_list(list *head){</span><br><span class="line">    int data;   //插入的数据类型</span><br><span class="line">    printf("请输入要插入的元素：");</span><br><span class="line">    scanf("%d",&data);</span><br><span class="line">  </span><br><span class="line">    list *node=initlist();</span><br><span class="line">    node->data=data;</span><br><span class="line">    //初始化一个新的结点，准备进行链接</span><br><span class="line">  </span><br><span class="line">    if(head!=NULL){</span><br><span class="line">        list *p=head;</span><br><span class="line">        //找到最后一个数据</span><br><span class="line">        while(p->next!=head){</span><br><span class="line">            p=p->next;</span><br><span class="line">        }</span><br><span class="line">        p->next=node;</span><br><span class="line">        node->next=head;</span><br><span class="line">        return 1;</span><br><span class="line">    }else{</span><br><span class="line">        printf("头结点已无元素\n");</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="循环单链表的插入操作"><a href="#循环单链表的插入操作" class="headerlink" title="循环单链表的插入操作"></a>循环单链表的插入操作</h3><p>如图，对于插入数据的操作，可以创建一个独立的结点，通过将需要插入的结点的上一个结点的next指针指向该节点，再由需要插入的结点的next指针指向下一个结点的方式完成插入操作。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081430.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081430.png" class="lazyload" title></a></p><p>其代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//插入元素</span><br><span class="line">list *insert_list(list *head,int pos,int data){</span><br><span class="line">    //三个参数分别是链表，位置，参数</span><br><span class="line">    list *node=initlist();  //新建结点</span><br><span class="line">    list *p=head;       //p表示新的链表</span><br><span class="line">    list *t;</span><br><span class="line">    t=p;</span><br><span class="line">    node->data=data;</span><br><span class="line">    if(head!=NULL){</span><br><span class="line">        for(int i=1;i<pos;i++){< span><br><span class="line">            t=t->next;  //走到需要插入的位置处</span><br><span class="line">        }</span><br><span class="line">        node->next=t->next;</span><br><span class="line">        t->next=node;</span><br><span class="line">        return p;</span><br><span class="line">    }</span><br><span class="line">    return p;</span><br><span class="line">}</span><br></pos;i++){<></span></pre></td></tr></tbody></table></figure></div><h3 id="循环单链表的删除操作"><a href="#循环单链表的删除操作" class="headerlink" title="循环单链表的删除操作"></a>循环单链表的删除操作</h3><p>如下图所示，循环单链表的删除操作是先找到需要删除的结点，将其前一个结点的next指针直接指向删除结点的下一个结点即可。</p><p>需要注意的是尾结点，因为删除尾节点后，尾节点前一个结点就成了新的尾节点，这个新的尾节点需要指向的是头结点而不是空。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081457.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019081457.png" class="lazyload" title></a></p><p>其代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//删除元素</span><br><span class="line">int delete_list(list *head) {</span><br><span class="line">    if(head == NULL) {</span><br><span class="line">        printf("链表为空！\n");</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line">    //建立临时结点存储头结点信息（目的为了找到退出点）</span><br><span class="line">    //如果不这么建立的化需要使用一个数据进行计数标记，计数达到链表长度时自动退出</span><br><span class="line">    //循环链表当找到最后一个元素的时候会自动指向头元素，这是我们不想让他发生的</span><br><span class="line">    list *temp = head;          </span><br><span class="line">    list *ptr = head->next;</span><br><span class="line">  </span><br><span class="line">    int del;</span><br><span class="line">    printf("请输入你要删除的元素：");</span><br><span class="line">    scanf("%d",&del);</span><br><span class="line">  </span><br><span class="line">    while(ptr != head) {</span><br><span class="line">        if(ptr->data == del) {</span><br><span class="line">            if(ptr->next == head) { </span><br><span class="line">                temp->next = head;</span><br><span class="line">                free(ptr);</span><br><span class="line">                return 1;</span><br><span class="line">            }</span><br><span class="line">            temp->next = ptr->next;    //核心删除操作代码</span><br><span class="line">            free(ptr);</span><br><span class="line">            //printf("元素删除成功！\n");</span><br><span class="line">            return 1;</span><br><span class="line">        }</span><br><span class="line">        temp = temp->next;</span><br><span class="line">        ptr = ptr->next;</span><br><span class="line">    }</span><br><span class="line">    printf("没有找到要删除的元素\n");</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="循环单链表的遍历"><a href="#循环单链表的遍历" class="headerlink" title="循环单链表的遍历"></a>循环单链表的遍历</h3><p>与普通的单链表和双向链表的遍历不同，循环链表需要进行结点的特殊判断。</p><p>先找到尾节点的位置，由于尾节点的next指针是指向头结点的，所以不能使用链表本身是否为空（NULL）的方法进行简单的循环判断，我们需要通过判断结点的next指针是否等于头结点的方式进行是否完成循环的判断。</p><p>此外还有一种计数的方法，即建立一个计数器<code>count=0</code>，每一次next指针指向下一个结点时计数器+1，当count数字与链表的节点数相同的时候即完成循环；</p><p>但是这样做会有一个问题，就是获取到链表的节点数同时，也需要完成一次遍历才可以达成目标。</p><p>其代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//遍历元素</span><br><span class="line">int display(list *head) {</span><br><span class="line">    if(head != NULL) {</span><br><span class="line">        list *p  = head;</span><br><span class="line">        //遍历头节点到，最后一个数据</span><br><span class="line">        while(p->next != head ) {</span><br><span class="line">            printf("%d   ",p->next->data);</span><br><span class="line">            p = p->next;</span><br><span class="line">        }</span><br><span class="line">        printf("\n");   //换行</span><br><span class="line">        //把最后一个节点赋新的节点过去</span><br><span class="line">        return 1;</span><br><span class="line">    } else {</span><br><span class="line">        printf("头结点为空!\n");</span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="进阶概念——双向循环链表"><a href="#进阶概念——双向循环链表" class="headerlink" title="进阶概念——双向循环链表"></a>进阶概念——双向循环链表</h3><p>循环单链表也有一个孪生兄弟——双向循环链表，其设计思路与单链表和双向链表的设计思路一样，就是在原有的双向链表的基础上，将尾部结点和头部结点进行互相连接。交给大家了。</p><h2 id="关于链表的总结"><a href="#关于链表的总结" class="headerlink" title="关于链表的总结"></a>关于链表的总结</h2><p>在顺序表中做插入删除操作时，平均移动大约表中一半的元素，因此对n较大的顺序表效率低。并且需要预先分配足够大的存储空间，而链表恰恰是其中运用的精华。</p><p>基于存储，运算，环境这几方面考虑，可以让我们更好的在项目中使用链表。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法-二分查找</title>
      <link href="/posts/1733554744/"/>
      <url>/posts/1733554744/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>二分查找也称折半查找（Binar Search)，是一种在<code>有序</code>数组中查找某一特定元素的搜索算法。<br>搜索过程：  </p><ul><li>从数组的中间开始搜索，如果中间的元素正好是要查找的元素，则搜索过程结束。</li><li>如果该值大于中间元素，则在数组大于中间的那一半查找。</li><li>如果该值小于中间元素，则在数组小于中间的那一半查找。</li><li>而且再次查找的过程回到第一步，在该部分的中间元素开始。直到找到该元素或者数组为空。</li></ul><p>其时间的复杂度为O（logn），空间复杂度o（1）</p><p>二分法很容易理解，但是细节是魔鬼，要写出一个正确的二分法不是一件容易的事情。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>首先我们了解一下其基本的实现，nums为有序数组，len为其长度，target为要寻找的目标</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找一个数,如果存在返回其索引，否则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left <= right) {</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] < target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] > target) {</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>当然我们也要学会拒绝造轮子嘛 O(∩_∩)O  </p><p>包含这个头文件<stdlib.h>我们就可以使用库函数了。  </stdlib.h></p><p>void <em>bsearch(const void <em>key, const void *base, size_t nitems, size_t size, int (</em>compare)(const void *, const void</em>));<br>key – 要查找的元素<br>base – 指向要排序的数组的第一个元素的指针。<br>nitems – 由 base 指向的数组中元素的个数。<br>size– 数组中每个元素的大小，以字节为单位。<br>compare – 用来比较两个元素的函数，即函数指针（回调函数）  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE 5</span></span><br><span class="line"><span class="keyword">int</span> values[ARRAY_SIZE] = { <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">// compare函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmpfunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span>* item;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    item = (<span class="keyword">int</span>*)bsearch(&key, values, ARRAY_SIZE, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmpfunc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"lib index =%d\n"</span>, (<span class="keyword">int</span>)(item - values) < <span class="number">0</span> ? <span class="number">-1</span> : (<span class="keyword">int</span>)(item - values)); <span class="comment">//如果存在输出其索引，否则输出-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>有时候我们可能想要最先出现的那个值，那么就需要我们把左值找出来  </p><p>寻找左侧边界</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找左侧边界</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftBoundSearch</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len;</span><br><span class="line">    <span class="keyword">while</span> (left < right) {</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            right = mid;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] < target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] > target) {</span><br><span class="line">            right = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (left == len) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>有时候我们可能想要最后出现的那个值，那么就需要我们把右值找出来  </p><p>寻找右侧边界</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找右侧边界</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightBoundSearch</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len;</span><br><span class="line">    <span class="keyword">while</span> (left < right) {</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] < target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] > target) {</span><br><span class="line">            right = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? (left - <span class="number">1</span>) : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>那么我们放到一起来体验一下把</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 二分法 在数组中查找值 32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> values[ARRAY_SIZE] = { <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">// compare函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmpfunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找一个数,如果存在返回其索引，否则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left <= right) {</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] < target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] > target) {</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 寻找左侧边界</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftBoundSearch</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len;</span><br><span class="line">    <span class="keyword">while</span> (left < right) {</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            right = mid;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] < target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] > target) {</span><br><span class="line">            right = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (left == len) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 寻找右侧边界</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightBoundSearch</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len;</span><br><span class="line">    <span class="keyword">while</span> (left < right) {</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] < target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] > target) {</span><br><span class="line">            right = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? (left - <span class="number">1</span>) : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span>* item;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">112</span>;</span><br><span class="line"></span><br><span class="line">    item = (<span class="keyword">int</span>*)bsearch(&key, values, ARRAY_SIZE, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmpfunc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"lib index =%d\n"</span>, (<span class="keyword">int</span>)(item - values) < <span class="number">0</span> ? <span class="number">-1</span> : (<span class="keyword">int</span>)(item - values));</span><br><span class="line"></span><br><span class="line">    res = binarySearch(values, ARRAY_SIZE, key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"std index =%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    res = leftBoundSearch(values, ARRAY_SIZE, key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"lft index =%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    res = rightBoundSearch(values, ARRAY_SIZE, key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rgt index =%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lib index =2</span><br><span class="line">std index =2</span><br><span class="line">lft index =0</span><br><span class="line">rgt index =4</span><br></pre></td></tr></tbody></table></figure></div><h2 id="光说不练假把式"><a href="#光说不练假把式" class="headerlink" title="光说不练假把式"></a>光说不练假把式</h2><p>我们在leetcode上来找两个例题试试手。  </p><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p><p>这个很明显的就是要用二分法嘛，虽然官方给了两个方法</p><p>1：线性扫描方法 </p><p>2：二分查找</p><p>但是方法一线性扫描时间复杂度肯定不满足嘛，相信用上面的例子很容易改出答案来。</p><h3 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a>875. 爱吃香蕉的珂珂</h3><p>我们在看一个不是特别明显的例子。  </p><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p>示例 1：</p><p>输入: piles = [3,6,7,11], H = 8<br>输出: 4<br>示例 2：</p><p>输入: piles = [30,11,23,4,20], H = 5<br>输出: 30<br>示例 3：</p><p>输入: piles = [30,11,23,4,20], H = 6<br>输出: 23</p><p>题解</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>* piles, <span class="keyword">int</span> pilesSize, <span class="keyword">int</span> H)</span></span>{</span><br><span class="line"></span><br><span class="line">    qsort(piles, pilesSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);<span class="comment">//先排成有序数组</span></span><br><span class="line">    / *  二分法查找左值 */</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>; ;</span><br><span class="line">    <span class="keyword">int</span> right = piles[pilesSize<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left < right) {</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i<pilessize; i++) {< span><br><span class="line">            time += (piles[i] + (mid - <span class="number">1</span>)) / mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (time > H)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br></pilessize;></span></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-快排</title>
      <link href="/posts/4264057631/"/>
      <url>/posts/4264057631/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>快速排序算法是由东尼·霍尔所发明的一种排序算法，属于交换排序的一种，其时间复杂度平均情况为O（nlog2n）最坏的情况为O（n2），空间复杂度为O（nlog2n），属于不稳定排序，n比较大时，效果明显。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序时使用的典型的分治法，该方法的基本思路是：</p><ul><li><p>从数列中挑出一个元素，称为基准（pivot）。（找基准的步骤中存在不同的实现，比如选择首位元素、中间元素、随机元素等）</p></li><li><p>重新排序数列，所有元素比基准小的摆在基准前面，所有元素比基准大值大的摆在基准后面，相同的可以在基准的任何一边，在这个分区退出后，该基准就在中间位置。这个成为分区操作。</p></li><li><p>递归地把小于基准的子序列和大于基准的子序列排序。</p></li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (len <= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>, temp = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (i < j) {</span><br><span class="line">        <span class="keyword">while</span> (a[j] > temp && j > i)</span><br><span class="line">            j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span> (a[i] <= temp && i < j)</span><br><span class="line">            i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    }</span><br><span class="line">    a[i] = temp;</span><br><span class="line">    qsort(a, i);</span><br><span class="line">    qsort(a + i + <span class="number">1</span>, len - i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, a[<span class="number">13</span>] = { <span class="number">-100</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">-10</span>, <span class="number">9</span>, <span class="number">46</span>, <span class="number">-4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">44</span>, <span class="number">20</span> };</span><br><span class="line">    qsort(a, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < <span class="number">13</span>; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="拒绝重复造轮子"><a href="#拒绝重复造轮子" class="headerlink" title="拒绝重复造轮子"></a>拒绝重复造轮子</h2><p>当然我们也可以直接使用库函数，需要包含头文件stdlib.h。</p><pre><code>用 法： void qsort(void *base,int nelem,int width,int (*fcmp)(const void *,const void *));参数： 1 待排序数组首元素的地址 2 数组中待排序元素数量3 各元素的占用空间大小4 指向函数的指针，用于确定排序的顺序 </code></pre><p>使用库函数我们很方便，只需要构造comp就可以了，我们看几个常规的例子：</p><p>int 排序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b; <span class="comment">// 递增</span></span><br><span class="line">    <span class="comment">//return *(int*)b - *(int*)a; // 递减</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">13</span>] = { <span class="number">-100</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">-10</span>, <span class="number">9</span>, <span class="number">46</span>, <span class="number">-4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">44</span>, <span class="number">20</span> };</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    qsort(a, len, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]), comp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < len; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>double 排序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> ((*(<span class="keyword">double</span>*)a - *(<span class="keyword">double</span>*)b > <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>); <span class="comment">//升序</span></span><br><span class="line">    <span class="comment">//return ((*(double*)a - *(double*)b > 0) ? -1 : 1); //降序</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">double</span> s[N] = { <span class="number">1.45</span>, <span class="number">5.78</span>, <span class="number">9.754</span>, <span class="number">124.145</span>, <span class="number">148.15</span>, <span class="number">654.0</span> };</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    qsort(s, N, <span class="keyword">sizeof</span>(s[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf "</span>, s[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>再比如，按照字符串的长度排序：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><string.h></string.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>((<span class="keyword">char</span>*)a) - <span class="built_in">strlen</span>((<span class="keyword">char</span>*)b); <span class="comment">//递增</span></span><br><span class="line">    <span class="comment">//return strlen((char*)b) - strlen((char*)a); //递减</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> s[M][N] = {</span><br><span class="line">        <span class="string">"January"</span>,</span><br><span class="line">        <span class="string">"February"</span>,</span><br><span class="line">        <span class="string">"March"</span>,</span><br><span class="line">        <span class="string">"April"</span>,</span><br><span class="line">        <span class="string">"May"</span>,</span><br><span class="line">        <span class="string">"June"</span>,</span><br><span class="line">        <span class="string">"July"</span>,</span><br><span class="line">        <span class="string">"August"</span>,</span><br><span class="line">        <span class="string">"September"</span>,</span><br><span class="line">        <span class="string">"October"</span>,</span><br><span class="line">        <span class="string">"November"</span>,</span><br><span class="line">        <span class="string">"December"</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    qsort(s, M, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * N, comp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < M; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>按照字典序排序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><string.h></string.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span>*)a - *(<span class="keyword">char</span>*)b; <span class="comment">//字典升序</span></span><br><span class="line">    <span class="comment">//return *(char*)b - *(char*)a;//字典降序</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> s[M][N] = {</span><br><span class="line">        <span class="string">"January"</span>,</span><br><span class="line">        <span class="string">"February"</span>,</span><br><span class="line">        <span class="string">"March"</span>,</span><br><span class="line">        <span class="string">"April"</span>,</span><br><span class="line">        <span class="string">"May"</span>,</span><br><span class="line">        <span class="string">"June"</span>,</span><br><span class="line">        <span class="string">"July"</span>,</span><br><span class="line">        <span class="string">"August"</span>,</span><br><span class="line">        <span class="string">"September"</span>,</span><br><span class="line">        <span class="string">"October"</span>,</span><br><span class="line">        <span class="string">"November"</span>,</span><br><span class="line">        <span class="string">"December"</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    qsort(s, M, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * N, comp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < M; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>struct 排序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">} Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> ((Student*)a)->score - ((Student*)b)->score;<span class="comment">//按成绩</span></span><br><span class="line">    <span class="comment">//return *(((Student*)a)->name) - *(((Student*)b)->name);//按名字</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Student s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-15s : %d\n"</span>, s.name, s.score);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Student s[N] = {</span><br><span class="line">        <span class="string">"Zhang San"</span>, <span class="number">94</span>,</span><br><span class="line">        <span class="string">"Li Si"</span>, <span class="number">80</span>,</span><br><span class="line">        <span class="string">"You"</span>, <span class="number">94</span>,</span><br><span class="line">        <span class="string">"I"</span>, <span class="number">100</span>,</span><br><span class="line">        <span class="string">"He"</span>, <span class="number">72</span>,</span><br><span class="line">        <span class="string">"She"</span>, <span class="number">60</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    qsort(s, N, <span class="keyword">sizeof</span>(Student), comp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < N; i++) {</span><br><span class="line">        <span class="built_in">print</span>(s[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>通过上面的几个例子，我们不难发现，其实我们只要构造好comp函数就好了。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要从头开始学习算法啦</title>
      <link href="/posts/1711964220/"/>
      <url>/posts/1711964220/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这个起因说起来还很不好意思呢，最开始接触算法的时候是在高中的时候，一次上计算机课程，老师问有没有想参加NOIP的，当时不是很懂，老师解释说是学习计算机编程，通过相关算法解决问题，因为比较年轻，对新鲜的事物充满了好奇，于是就报名了。后来有了大部分时间可以泡在机房里了，但是当时其实对算法不怎么感兴趣，虽然也学过什么快排、堆排、动态规划、二叉树、背包问题什么的，因为当时心思不在这个上面，和几个小玩伴把方向走偏了，其实大部时间泡在机房都是去搞信息安全和看动漫去了，所以理所当然NOIP成绩很糟糕，也错失了保送名牌大学的机会。</p><p>同时由于大部分时间泡在机房里，所以文化课多多少少会有些影响，后来父母知道后对我进行了禁止接触计算机的管制，并且一致认为去搞计算机没什么前途（大概在10多年前吧），后来高考结束后，勉勉强强考了一个211，父母当时坚决抵制我进行报计算机、软件等相关专业，希望我去做医生、老师、海关、税务等，我们进行和友好协商，最后报了机械工程学院。哈哈哈，然后开启了更苦逼的生涯。</p><hr><p>其实在刚上大学的时候，很多计算机的相关技能都没有荒废，所以相关课程成绩很是突出，然后大一的时候我们宿舍组团选修了《计算机游戏设计基础》这门课程，当时也是为了蹭点学分，觉得选修课程也没什么，后来去上课发现，除了我们其余都是计算机专业的，要组小队，然后我们7个业余的机械专业的自成一个小队，（我们尝试过加入其他小队，但是他们不接纳，他们也是组团玩的）气死了。。。后来就变成我挑起这个小队的大梁，勉勉强强完成最初是的DEMO，算是把这个小队成功的带过及格圈里。</p><p>不过我们小队成功的引起了老师的注意，老师私下要招募我，怂恿我去转专业，然后好好带我，将来年薪400k起步，当时可能被禁止接触计算机太久了，果断的拒绝了老师，立志要为中国的机械行业添砖加瓦，老师说他还有二级钳工的证书，当时我的理解，二级钳工就可以去做核弹、原子弹这类的了（别问我哪里知道的，我不会告诉你是《五号特工组》里的托马斯西奥），我还很是遗憾的劝诫老师为啥不在机械行业里深耕，将来或许和钱学森前辈齐名呢（现在想起来，恨不得抽自己俩大嘴巴）就这样我离这个行当越来越远了，后来下个学期选修的时候，我发现了《计算机游戏设计基础》这门课的报名门槛已经变成了仅限计算机专业大二及以上年级选修，不知道是不是我们机械小队给了老师一记暴击。。。</p><hr><p>后来大学终于毕业了，也慢慢看清楚了目前的格局，很是后悔啊。好在还有机会来修正路线，现在刚刚换了工作，和以前的机械行业、自动化行业挥挥手~~顺利的加入码农大军。<br>好了，不知不觉又扯远了，回过来将正题，已经超过5年没写过代码了，很多东西都已经王的差不多了，那就重新开始吧。</p><hr><p>那么最直接的引子是什么呢，入职后的第一次模拟考试，看到题目和提示，我已经知道大概可以用动态规划来解决，但是，我不会了！！不会了！！不会了！！啊啊啊啊。。。好气啊，然后最后只能老老实实的按照逻辑写，虽然最后通过了，但是没有双百（时间复杂度和空间复杂度超过100%的提交人），不开心，怀疑我有洁癖。</p><p>好了，在哪里跌倒就在那里站起来，看来以后要熬夜看算法和熟悉语法了。SSSS<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/v2-1f601b8c4987a6954a4e3aa53f4ec53b_hd.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/v2-1f601b8c4987a6954a4e3aa53f4ec53b_hd.jpg" class="lazyload" title></a></p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是一篇关于markdown语法的测试</title>
      <link href="/posts/3632233996/"/>
      <url>/posts/3632233996/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><hr><h1 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h1><p>***、—、___可以显示横线效果</p><hr><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><h3 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h3><p>这是一段普通的文本</p><h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><pre><code>Hello,大家好，我是ymz。</code></pre><p>在一行开头加入1个Tab或者4个空格。</p><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><h4 id="语法1"><a href="#语法1" class="headerlink" title="语法1"></a>语法1</h4><p>在连续几行的文本开头加入1个Tab或者4个空格。</p><pre><code>欢迎到访很高兴见到您祝您，早上好，中午好，下午好，晚安</code></pre><h4 id="语法2"><a href="#语法2" class="headerlink" title="语法2"></a>语法2</h4><p>使用一对各三个的反引号：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">欢迎到访</span><br><span class="line">我是C++码农</span><br><span class="line">你可以在知乎、CSDN、简书搜索【ymz】找到我</span><br></pre></td></tr></tbody></table></figure></div><p>该语法也可以实现代码高亮，见<a href="#代码高亮">代码高亮</a></p><h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><p>文字高亮功能能使行内部分文字高亮，使用一对反引号。<br>语法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`linux` `网络编程` `socket` `epoll`</span><br></pre></td></tr></tbody></table></figure></div><p>效果：<code>linux</code> <code>网络编程</code> <code>socket</code> <code>epoll</code></p><p>也适合做一篇文章的tag</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>直接回车不能换行，<br>可以在上一行文本后面补两个空格，<br>这样下一行的文本就换行了。</p><p>或者就是在两行文本直接加一个空行。</p><p>也能实现换行效果，不过这个行间距有点大。</p><h4 id="斜体、粗体、删除线"><a href="#斜体、粗体、删除线" class="headerlink" title="斜体、粗体、删除线"></a>斜体、粗体、删除线</h4><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td><code>*斜体1*</code></td><td><em>斜体1</em></td></tr><tr><td><code>_斜体2_</code></td><td><em>斜体2</em></td></tr><tr><td><code>**粗体1**</code></td><td><strong>粗体1</strong></td></tr><tr><td><code>__粗体2__</code></td><td><strong>粗体2</strong></td></tr><tr><td><code>这是一个 ~~删除线~~</code></td><td>这是一个 <del>删除线</del></td></tr><tr><td><code>***斜粗体1***</code></td><td><strong><em>斜粗体1</em></strong></td></tr><tr><td><code>___斜粗体2___</code></td><td><strong><em>斜粗体2</em></strong></td></tr><tr><td><code>***~~斜粗体删除线1~~***</code></td><td><strong><em><del>斜粗体删除线1</del></em></strong></td></tr><tr><td><code>~~***斜粗体删除线2***~~</code></td><td><del><strong><em>斜粗体删除线2</em></strong></del></td></tr></tbody></table><pre><code>斜体、粗体、删除线可混合使用</code></pre><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>基本格式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt](URL title)</span><br></pre></td></tr></tbody></table></figure></div><p>alt和title即对应HTML中的alt和title属性（都可省略）：</p><ul><li>alt表示图片显示失败时的替换文本</li><li>title表示鼠标悬停在图片时的显示文本（注意这里要加引号）</li></ul><p>URL即图片的url地址，如果引用本仓库中的图片，直接使用<strong>相对路径</strong>就可了，如果引用其他github仓库中的图片要注意格式，即：<code>仓库地址/raw/分支名/图片路径</code>，如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif</span><br></pre></td></tr></tbody></table></figure></div><table><thead><tr><th>#</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>1</td><td><code>![baidu](http://www.baidu.com/img/bdlogo.gif "百度logo")</code></td><td><a href="http://www.baidu.com/img/bdlogo.gif" data-fancybox="group" data-caption="baidu" class="fancybox"><img alt="baidu" title="baidu" data-src="http://www.baidu.com/img/bdlogo.gif" class="lazyload"></a></td></tr><tr><td>2</td><td><code>![][code-past]</code></td><td>![][code-past]</td></tr></tbody></table><p>注意例2的写法使用了<strong>URL标识符</strong>的形式，在<a href="#链接">链接</a>一节有介绍。</p><blockquote><p>在文末有code-past的定义：</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[code-past]:https://img-blog.csdnimg.cn/201908060004034.png</span><br></pre></td></tr></tbody></table></figure></div><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h3 id="链接外部URL"><a href="#链接外部URL" class="headerlink" title="链接外部URL"></a>链接外部URL</h3><table><thead><tr><th>#</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>1</td><td><code>[我的博客](http://blog.csdn.net/guodongxiaren "悬停显示")</code></td><td><a href="http://blog.csdn.net/guodongxiaren" target="_blank" rel="noopener" title="悬停显示">我的博客</a></td></tr><tr><td>2</td><td><code>[我的知乎][zhihu]</code></td><td>[我的知乎][zhihu]</td></tr></tbody></table><p>语法2由两部分组成：</p><ul><li>第一部分使用两个中括号，[ ]里的标识符（本例中zhihu），可以是数字，字母等的组合，标识符上下对应就行了（<strong>姑且称之为URL标识符</strong>）</li><li>第二部分标记实际URL。</li></ul><blockquote><p>使用URL标识符能达到复用的目的，一般把全文所有的URL标识符统一放在文章末尾，这样看起来比较干净。</p><blockquote><p>URL标识符是我起的名字，不知道是否准确。囧。。</p></blockquote></blockquote><h3 id="链接本仓库里的URL"><a href="#链接本仓库里的URL" class="headerlink" title="链接本仓库里的URL"></a>链接本仓库里的URL</h3><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td><code>[我的简介](/example/profile.md)</code></td><td><a href="/example/profile.md">我的简介</a></td></tr><tr><td><code>[example](./example)</code></td><td><a href="./example">example</a></td></tr></tbody></table><h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><p>给图片加链接的本质是混合图片显示语法和普通的链接语法。普通的链接中[ ]内部是链接要显示的文本，而图片链接[ ]里面则是要显示的图片。<br>直接混合两种语法当然可以，但是十分啰嗦，为此我们可以使用URL标识符的形式。</p><table><thead><tr><th>#</th><th>语法</th><th align="center">效果</th></tr></thead><tbody><tr><td>1</td><td><code>[![weibo-logo]](http://weibo.com/linpiaochen)</code></td><td align="center"><a href="http://weibo.com/linpiaochen" target="_blank" rel="noopener">![weibo-logo]</a></td></tr><tr><td>2</td><td><code>[![](/img/zhihu.png "我的知乎，欢迎关注")][zhihu]</code></td><td align="center">[<a href="/img/zhihu.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/img/zhihu.png" class="lazyload"></a>][zhihu]</td></tr><tr><td>3</td><td><code>[![csdn-logo]][csdn]</code></td><td align="center">[![csdn-logo]][csdn]</td></tr></tbody></table><p>因为图片本身和链接本身都支持URL标识符的形式，所以图片链接也可以很简洁（见例3）。<br>注意，此时鼠标悬停时显示的文字是图片的title，而非链接本身的title了。</p><blockquote><p>本文URL标识符都放置于文末</p></blockquote><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>其实呢，每一个标题都是一个锚点，和HTML的锚点（<code>#</code>）类似，比如我们 </p><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td><code>[回到顶部](#readme)</code></td><td><a href="#readme">回到顶部</a></td></tr></tbody></table><p>不过要注意，标题中的英文字母都被转化为<strong>小写字母</strong>了。</p><blockquote><p>以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 昵称：ymz</span><br><span class="line">- 别名：夜忙猪</span><br><span class="line">* 英文名：ymz</span><br></pre></td></tr></tbody></table></figure></div><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><ul><li>昵称：ymz</li></ul><ul><li>别名：隔壁老王</li></ul><ul><li>英文名：ymz</li></ul><h3 id="多级无序列表"><a href="#多级无序列表" class="headerlink" title="多级无序列表"></a>多级无序列表</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 编程语言</span><br><span class="line">    * 脚本语言</span><br><span class="line">        * Python</span><br></pre></td></tr></tbody></table></figure></div><h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><ul><li>编程语言<ul><li>脚本语言<ul><li>Python</li></ul></li></ul></li></ul><h3 id="一级有序列表"><a href="#一级有序列表" class="headerlink" title="一级有序列表"></a>一级有序列表</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>就是在数字后面加一个点，再加一个空格。不过看起来起来可能不够明显。 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向对象的三个基本特征：</span><br><span class="line"></span><br><span class="line">1. 封装</span><br><span class="line">2. 继承</span><br><span class="line">3. 多态</span><br></pre></td></tr></tbody></table></figure></div><h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><p>面向对象的三个基本特征：</p><ol><li>封装</li><li>继承</li><li>多态</li></ol><h3 id="多级有序列表"><a href="#多级有序列表" class="headerlink" title="多级有序列表"></a>多级有序列表</h3><p>和无序列表一样，有序列表也有多级结构。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 这是一级的有序列表，数字1还是1</span><br><span class="line">   1. 这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字</span><br><span class="line">      1. 这是三级的有序列表，数字在显示的时候变成了英文字母</span><br></pre></td></tr></tbody></table></figure></div><h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><ol><li>这是一级的有序列表，数字1还是1<ol><li>这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字<ol><li>这是三级的有序列表，数字在显示的时候变成了英文字母</li></ol></li></ol></li></ol><h3 id="复选框列表"><a href="#复选框列表" class="headerlink" title="复选框列表"></a>复选框列表</h3><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- [x] 需求分析</span><br><span class="line">- [x] 系统设计</span><br><span class="line">- [x] 详细设计</span><br><span class="line">- [ ] 编码</span><br><span class="line">- [ ] 测试</span><br><span class="line">- [ ] 交付</span><br></pre></td></tr></tbody></table></figure></div><h4 id="效果-4"><a href="#效果-4" class="headerlink" title="效果"></a>效果</h4><ul><li><input checked disabled type="checkbox"> 需求分析</li><li><input checked disabled type="checkbox"> 系统设计</li><li><input checked disabled type="checkbox"> 详细设计</li><li><input disabled type="checkbox"> 编码</li><li><input disabled type="checkbox"> 测试</li><li><input disabled type="checkbox"> 交付</li></ul><p>您可以使用这个功能来标注某个项目各项任务的完成情况。</p><blockquote><p>Tip:</p><blockquote><p>在GitHub的<strong>issue</strong>中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。</p></blockquote></blockquote><h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><h3 id="常用于引用文本"><a href="#常用于引用文本" class="headerlink" title="常用于引用文本"></a>常用于引用文本</h3><h4 id="文本摘自《深入理解计算机系统》P27"><a href="#文本摘自《深入理解计算机系统》P27" class="headerlink" title="文本摘自《深入理解计算机系统》P27"></a>文本摘自《深入理解计算机系统》P27</h4><p>　令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。</p><blockquote><p><strong>“端”（endian）的起源</strong><br>以下是Jonathan Swift在1726年关于大小端之争历史的描述：<br>“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。”</p></blockquote><h3 id="块引用有多级结构"><a href="#块引用有多级结构" class="headerlink" title="块引用有多级结构"></a>块引用有多级结构</h3><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">> 数据结构</span><br><span class="line">>> 树</span><br><span class="line">>>> 二叉树</span><br><span class="line">>>>> 平衡二叉树</span><br><span class="line">>>>>> 满二叉树</span><br></pre></td></tr></tbody></table></figure></div><h4 id="效果-5"><a href="#效果-5" class="headerlink" title="效果"></a>效果</h4><blockquote><p>数据结构</p><blockquote><p>树</p><blockquote><p>二叉树</p><blockquote><p>平衡二叉树</p><blockquote><p>满二叉树</p></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>在三个反引号后面加上编程语言的名字，另起一行开始写代码，最后一行再加上三个反引号。</p><h3 id="效果-6"><a href="#效果-6" class="headerlink" title="效果"></a>效果</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>{} <span class="comment">//Java</span></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">//C</span></span></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello GitHub"</span> <span class="comment">#Bash</span></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myH1"</span>).innerHTML=<span class="string">"Welcome to my Homepage"</span>; <span class="comment">//javascipt</span></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> &<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">string</span>& A,<span class="keyword">const</span> <span class="built_in">string</span>& B) <span class="comment">//cpp</span></span><br></pre></td></tr></tbody></table></figure></div><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>表格单元</td><td>表格单元</td></tr><tr><td>表格单元</td><td>表格单元</td></tr></tbody></table><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>表格单元</td><td>表格单元</td></tr><tr><td>表格单元</td><td>表格单元</td></tr></tbody></table><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>表格可以指定对齐方式</p><table><thead><tr><th align="left">左对齐</th><th align="center">居中</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h3 id="混合其他语法"><a href="#混合其他语法" class="headerlink" title="混合其他语法"></a>混合其他语法</h3><p>表格单元中的内容可以和其他大多数GFM语法配合使用，如：  </p><h4 id="使用普通文本的删除线，斜体等效果"><a href="#使用普通文本的删除线，斜体等效果" class="headerlink" title="使用普通文本的删除线，斜体等效果"></a>使用普通文本的删除线，斜体等效果</h4><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>Help</td><td><del>Display the</del> help window.</td></tr><tr><td>Close</td><td><em>Closes</em> a window</td></tr></tbody></table><h4 id="表格中嵌入图片（链接）"><a href="#表格中嵌入图片（链接）" class="headerlink" title="表格中嵌入图片（链接）"></a>表格中嵌入图片（链接）</h4><p>其实前面介绍图片显示、图片链接的时候为了清晰就是放在在表格中显示的。</p><table><thead><tr><th>图片</th><th>描述</th></tr></thead><tbody><tr><td>![baidu][baidu-logo]</td><td>百度</td></tr></tbody></table><h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p><p>比如<code>:blush:</code>，可以显示:blush:。</p><p>具体每一个表情的符号码，可以查询GitHub的官方网页<a href="http://www.emoji-cheat-sheet.com" target="_blank" rel="noopener">http://www.emoji-cheat-sheet.com</a>。</p><p>但是这个网页每次都打开<strong>奇慢</strong>。。所以我整理到了本repo中，大家可以直接在此查看<a href="./emoji.md">emoji</a>。</p><h2 id="diff语法"><a href="#diff语法" class="headerlink" title="diff语法"></a>diff语法</h2><p>版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。<br>GFM中可以显示的展示diff效果。使用绿色表示新增，红色表示删除。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p>其语法与代码高亮类似，只是在三个反引号后面写diff，<br>并且其内容中，可以用 <code>+</code>开头表示新增，<code>-</code>开头表示删除。<br>另外还有有 <code>!</code>和<code>#</code>的语法。</p><h4 id="效果-7"><a href="#效果-7" class="headerlink" title="效果"></a>效果</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">diff</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ 人闲桂花落，</span></span><br><span class="line"><span class="deletion">- 夜静春山空。</span></span><br><span class="line"><span class="addition">! 月出惊山鸟，</span></span><br><span class="line"># 时鸣春涧中。</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统软件架构设计</title>
      <link href="/posts/1628819533/"/>
      <url>/posts/1628819533/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>嵌入式是软件设计领域的一个分支，它自身的诸多特点决定了系统架构师的选择，同时它的一些问题又具有相当的通用性，可以推广到其他的领域。</p><p>提起嵌入式软件设计，传统的印象是单片机，汇编，高度依赖硬件。传统的嵌入式软件开发者往往只关注实现功能本身，而忽视诸如代码复用，数据和界面分离，可测试性等因素。从而导致嵌入式软件的质量高度依赖开发者的水平，成败系之一身。随着嵌入式软硬件的飞速发展，今天的嵌入式系统在功能，规模和复杂度各方面都有了极大的提升。比如，Marvell公司的PXA3xx系列的最高主频已经达到800Mhz，内建USB,WIFI,2D图形加速,32位DDR内存。在硬件上，今天的嵌入式系统已经达到甚至超过了数年前的PC平台。在软件方面，完善的操作系统已经成熟，比如Symbian, Linux, WinCE。基于完善的操作系统，诸如字处理，图像，视频，音频，游戏，网页浏览等各种应用程序层出不穷，其功能性和复杂度比诸PC软件不遑多让。原来多选用专用硬件和专用系统的一些商业设备公司也开始转换思路，以出色而廉价的硬件和完善的操作系统为基础，用软件的方式代替以前使用专有硬件实现的功能，从而实现更低的成本和更高的可变更，可维护性。</p><h2 id="2-决定架构的因素和架构的影响"><a href="#2-决定架构的因素和架构的影响" class="headerlink" title="2.决定架构的因素和架构的影响"></a>2.决定架构的因素和架构的影响</h2><p>架构不是一个孤立的技术的产物，它受多方面因素的影响。同时，一个架构又对软件开发的诸多方面造成影响。</p><p>下面举一个具体的例子。</p><p>摩托车的发动机在出厂前必须通过一系列的测试。在流水线上，发动机被送到每个工位上，由工人进行诸如转速，噪音，振动等方面的测试。要求实现一个嵌入式设备，具备以下基本功能:</p><ol><li>安装在工位上，工人上班前开启并登录。</li><li>通过传感器自动采集测试数据，并显示在屏幕上。</li><li>记录所有的测试结果，并提供统计功能。比如次品率。</li></ol><p>如果你是这个设备的架构师，哪些问题是在设计架构的时候应该关注的呢？</p><h3 id="2-1-常见的误解"><a href="#2-1-常见的误解" class="headerlink" title="2.1. 常见的误解"></a>2.1. 常见的误解</h3><h4 id="2-1-1-小型的系统不需要架构"><a href="#2-1-1-小型的系统不需要架构" class="headerlink" title="2.1.1. 小型的系统不需要架构"></a>2.1.1. 小型的系统不需要架构</h4><p>有相当多的嵌入式系统规模都较小，一般是为了某些特定的目的而设计的。受工程师认识，客户规模和项目进度的影响，经常不做任何架构设计，直接以实现功能为目标进行编码。这种行为表面上看满足了进度，成本，功能各方面的需求，但是从长远来看，在扩展和维护上付出的成本，要远远高于最初节约的成本。如果系统的最初开发者继续留在组织内并负责这个项目，那么可能一切都会正常，一旦他离开，后续者因为对系统细节的理解不足，就可能引入更多的错误。要注意，嵌入式系统的变更成本要远远高于一般的软件系统。好的软件架构，可以从宏观和微观的不同层次上描述系统，并将各个部分隔离，从而使新特性的添加和后续维护变得相对简单。</p><p>举一个城铁刷卡机的例子，这个例子在前面的课程中出现过。简单的城铁刷卡机只需要实现如下功能：</p><p>一个While循环足以实现这个系统，直接就可以开始编码调试。但是从一个架构师的角度，这里有没有值得抽象和剥离的部分呢？</p><ol><li>计费系统。计费系统是必须抽象的，比如从单次计费到按里程计费。</li><li>传感器系统。传感器包括磁卡感应器，投币器等。设备可能更换。</li><li>故障处理和恢复。考虑到较高的可靠性和较短的故障恢复时间，这部分有必要单独设计。</li></ol><p>未来很可能出现的需求变更：</p><ol><li>操作界面。是否需要抽象出专门的Model来？以备将来实现View。</li><li>数据统计。是否需要引入关系型数据库？</li></ol><p>如果直接以上面的流程图编码，当出现变更后，有多少代码可以复用？</p><p>不过，也不要因此产生过度的设计。架构应当立足满足当前需求，并适当的考虑重用和变更。</p><h3 id="2-1-2-敏捷开发不需要架构"><a href="#2-1-2-敏捷开发不需要架构" class="headerlink" title="2.1.2. 敏捷开发不需要架构"></a>2.1.2. 敏捷开发不需要架构</h3><p>极限编程，敏捷开发的出现使一些人误以为软件开发无需再做架构了。这是一个很大的误解。敏捷开发是在传统瀑布式开发流程出现明显弊端后提出的解决方案，所以它必然有一个更高的起点和对开发更严格的要求。而不是倒退到石器时代。事实上，架构是敏捷开发的一部分，只不过在形式上，敏捷开发推荐使用更高效，简单的方式来做设计。比如画在白板上然后用数码相机拍下的UML图；用用户故事代替用户用例等。测试驱动的敏捷开发更是强迫工程师在写实际代码前设计好组件的功能和接口，而不是直接开始写代码。敏捷开发的一些特征：</p><ol><li>针对比传统开发流程更大的系统</li><li>承认变化，迭代架构</li><li>简洁而不混乱</li><li>强调测试和重构</li></ol><h2 id="2-嵌入式环境下软件设计的特点"><a href="#2-嵌入式环境下软件设计的特点" class="headerlink" title="2. 嵌入式环境下软件设计的特点"></a>2. 嵌入式环境下软件设计的特点</h2><p>要谈嵌入式的软件架构，首先必须了解嵌入式软件设计的特点。</p><h3 id="2-1-和硬件密切相关"><a href="#2-1-和硬件密切相关" class="headerlink" title="2.1. 和硬件密切相关"></a>2.1. 和硬件密切相关</h3><p>嵌入式软件普遍对硬件有着相当的依赖性。这体现在几个方面：</p><ol><li>一些功能只能通过硬件实现,软件操作硬件，驱动硬件。</li><li>硬件的差异/变更会对软件产生重大影响。</li><li>没有硬件或者硬件不完善时，软件无法运行或无法完整运行。</li></ol><p>这些特点导致几方面的后果：</p><ol><li>软件工程师对硬件的理解和熟练程度会很大程度的决定软件的性能/稳定性等非功能性指标，而这部分一向是相对复杂的，需要资深的工程师才能保证质量。</li><li>软件对硬件设计高度依赖，不能保持相对稳定，可维护性和可重用性差</li><li>软件不能离开硬件单独测试和验证，往往需要和硬件验证同步进行，造成进度前松后紧，错误定位范围扩大。</li></ol><p>针对这些问题，有几方面的解决思路：</p><ol><li>用软件实现硬件功能。选用更强大的处理器，用软件来实现部分硬件功能，不仅可以降低对硬件的依赖，在响应变化，避免对特定型号和厂商的依赖方面都很有好处。这在一些行业里已经成为了趋势。在PC平台也经历了这样的过程，比如早期的汉卡。</li><li>将对硬件的依赖独立成硬件抽象层，尽可能使软件的其他部分硬件无关，并可以脱离硬件运行。一方面将硬件变更甚至换件的风险控制在有限的范围内，另一方面提高软件部分的可测试性。</li></ol><h2 id="2-2-稳定性要求高"><a href="#2-2-稳定性要求高" class="headerlink" title="2.2. 稳定性要求高"></a>2.2. 稳定性要求高</h2><p>大部分嵌入式软件都对程序的长期稳定运行有较高的要求。比如手机经常几个月开机，通讯设备则要求24*7正常运行，即使是通讯上的测试设备也要求至少正常运行8小时。为了稳定性的目标，有一些比较常用的设计手段：</p><ol><li>将不同的任务分布在独立的进程中。良好的模块化设计是关键</li><li>Watch Dog, Heart beat，重新启动失效的进程。</li><li>完善而统一的日志系统以快速定位问题。嵌入式设备一般缺乏有力的调试器，日志系统尤其重要。</li><li>将错误孤立在最小的范围内，避免错误的扩散和连锁反应。核心代码要经过充分的验证，对非核心代码，可以在监控或者沙盒中运行，避免其破坏整个系统。</li></ol><p>举例，Symbian上的GPRS访问受不同硬件和操作系统版本影响，功能不是非常稳定。其中有一个版本上当关闭GPRS连接时一定会崩溃，而且属于known issue。将GPRS连接，HTTP协议处理，文件下载等操作独立到一个进程中，虽然每次操作完毕该进程都会崩溃，对用户却没有影响。</p><ol><li>双备份这样的手段较少采用</li></ol><h2 id="2-3-内存不足"><a href="#2-3-内存不足" class="headerlink" title="2.3. 内存不足"></a>2.3. 内存不足</h2><p>虽然当今的嵌入式系统的内存比之以K计数的时代已经有了很大的提高，但是随着软件规模的增长，内存不足的问题依然时时困扰着系统架构师。有一些原则，架构师在进行设计决策的时候可以参考：</p><h3 id="2-3-1-虚拟内存技术"><a href="#2-3-1-虚拟内存技术" class="headerlink" title="2.3.1. 虚拟内存技术"></a>2.3.1. 虚拟内存技术</h3><p>有一些嵌入式设备需要处理巨大的数据量，而这些数据不可能全部装入内存中。一些嵌入式操作系统不提供虚拟内存技术，比如WinCE4.2每个程序最多只能使用32M内存。对这样的应用，架构师应该特别设计自己的虚拟内存技术。所谓的虚拟内存技术的核心是，将暂时不太可能使用的数据移出内存。这涉及到一些技术点：</p><ol><li>引用计数，正在使用的数据不能移出。</li><li>使用预测，预测下一个阶段某个数据的使用可能性。基于预测移出数据或者提前装入数据。</li><li>占位数据/对象。</li><li>高速缓存。在复杂数据结果下缓存高频率使用的数据，直接访问。</li><li>快速的持久化和装载。</li></ol><p>下图是一个全国电信机房管理系统的界面示意图：</p><p>每个节点下都有大量的数据需要装载，可以使用上述技术将内存占用降到最低。</p><h3 id="2-3-2-两段式构造"><a href="#2-3-2-两段式构造" class="headerlink" title="2.3.2. 两段式构造"></a>2.3.2. 两段式构造</h3><p>在内存有限的系统里，对象构造失败是必须要处理的问题,失败的原因中最常见的则是内存不足（实际上这也是对PC平台的要求，但是在实际中往往忽略，因为内存实在便宜）。两段式构造就是一种常用而有效的设计。举例来说：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CMySimpleClass:</span><br><span class="line">class CMySimpleClass</span><br><span class="line">{</span><br><span class="line">  public:</span><br><span class="line">  CMySimpleClass();</span><br><span class="line">  ~CMySimpleClass();</span><br><span class="line">  ...</span><br><span class="line">  private:</span><br><span class="line">  int SomeData;</span><br><span class="line">};</span><br><span class="line">CMyCompoundClass:</span><br><span class="line">class CMyCompoundClass</span><br><span class="line">{</span><br><span class="line">  public:</span><br><span class="line">  CMyCompoundClass();</span><br><span class="line">  ~CMyCompoundClass();</span><br><span class="line">  ...</span><br><span class="line">  private:</span><br><span class="line">  CMySimpleClass* iSimpleClass;</span><br><span class="line">};</span><br><span class="line">在CMyCompoundClass的构造函数里初始化iSimpleClass对象。</span><br><span class="line"></span><br><span class="line">CMyCompoundClass::CMyCompoundClass()</span><br><span class="line">{</span><br><span class="line">  iSimpleClass = new CMySimpleClass;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>当创建CMyCompoundClass的时候会发生什么呢？</p><p>CMyCompoundClass* myCompoundClass = new CMyCompoundClass;</p><ol><li>为CMyCompoundClass的对象分配内存</li><li>调用CMyCompoundClass对象的构造函数</li><li>在构造函数中创建一个CMySimpleClass的实例</li><li>构造函数结束返回</li></ol><p>一切看起来都很简单，但是如果第三步创建CMySimpleClass对象的时候发生内存不足的错误怎么办呢？构造函数无法返回任何错误信息以提示调用者构造没有成功。调用者于是获得了一个指向CMyCompoundClass的指针，但是这个对象并没有构造完整。</p><p>如果在构造函数中抛出异常会怎么样呢？这是个著名的噩梦，因为析构函数不会被调用，在创建CMySimpleClass对象之前如果分配了资源就会泄露。关于在构造函数中抛出异常可以单讲一个小时，但是有一个建议是：尽量避免在构造函数中抛出异常。</p><p>所以，使用两段式构造法是一个更好的选择。简单的说，就是在构造函数避免任何可能产生错误的动作，比如分配内存，而把这些动作放在构造完成之后，调用另一个函数。比如:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AddressBook* book = new AddressBook()</span><br><span class="line">If(!book->Construct())</span><br><span class="line">{</span><br><span class="line">  delete book;</span><br><span class="line">  book = NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这样可以保证当Construct不成功的时候释放已经分配的资源。</p><p>在最重要的手机操作系统Symbian上，二段式构造法普遍使用。</p><h3 id="2-3-3-内存分配器"><a href="#2-3-3-内存分配器" class="headerlink" title="2.3.3. 内存分配器"></a>2.3.3. 内存分配器</h3><p>不同的系统有着不同的内存分配的特点。有些要求分配很多小内存，有的则需要经常增长已经分配的内存。一个好的内存分配器对嵌入式的软件的性能有时具有重大的意义。应该在系统设计时保证整个系统使用统一的内存分配器，并且可以随时更换。</p><h3 id="2-3-4-内存泄漏"><a href="#2-3-4-内存泄漏" class="headerlink" title="2.3.4. 内存泄漏"></a>2.3.4. 内存泄漏</h3><p>内存泄漏对嵌入式系统有限的内存是非常严重的。通过使用自己的内存分配器，可以很容易的跟踪内存的分配释放情况，从而检测出内存泄漏的情况。</p><h2 id="2-4-处理器能力有限，性能要求高"><a href="#2-4-处理器能力有限，性能要求高" class="headerlink" title="2.4. 处理器能力有限，性能要求高"></a>2.4. 处理器能力有限，性能要求高</h2><p>这里不讨论实时系统，那是一块很大的专业话题。对一般的嵌入式系统而言，由于处理器能力有限，要特别注意性能的问题。一些很好的架构设计由于不能满足性能要求，最终导致整个项目的失败。</p><h3 id="2-4-1-抵御新技术的诱惑"><a href="#2-4-1-抵御新技术的诱惑" class="headerlink" title="2.4.1. 抵御新技术的诱惑"></a>2.4.1. 抵御新技术的诱惑</h3><p>架构师必须明白，新技术常常意味着复杂和更低的性能。即使这不是绝对的，由于嵌入式系统硬件性能所限，弹性较低。一旦发现新技术有和当初设想不同之处，就更难通过修改来适应。比如GWT技术。这是Google推出的Ajax开发工具，它可以让程序员像开发一个桌面应用程序一样开发Web的Ajax程序。这使得在嵌入式系统上用一套代码实现远程和本地操作界面成为了很容易的一件事。但是在嵌入式设备上运行B-S结构的应用，性能上是一个很大的挑战。同时，浏览器兼容方面的问题也很严重，GWT目前的版本还不够完善。</p><p>事实证明，嵌入式的远程控制方案还是要采用Activex,VNC或者其他的方案。</p><h3 id="2-4-2-不要有太多的层次"><a href="#2-4-2-不要有太多的层次" class="headerlink" title="2.4.2. 不要有太多的层次"></a>2.4.2. 不要有太多的层次</h3><p>分层结构有利于清晰的划分系统职责，实现系统的解耦，但是每多一个层次，就意味着性能的一次损失。尤其是当层和层之间需要传递大量数据的时候。对嵌入式系统而言，在采用分层结构时要控制层次数量，并且尽量不要传递大量数据，尤其是在不同进程的层次之间。如果一定要传递数据，要避免大量的数据格式转换，如XML到二进制，C++结构到Python结构。</p><p>嵌入式系统能力有限，一定要将有限的能力用在系统的核心功能上。</p><h2 id="2-5-存储设备易损坏，速度较慢"><a href="#2-5-存储设备易损坏，速度较慢" class="headerlink" title="2.5. 存储设备易损坏，速度较慢"></a>2.5. 存储设备易损坏，速度较慢</h2><p>受体积和成本的限制，大部分的嵌入式设备使用诸如Compact Flash, SD, mini SD, MMC等作为存储设备。这些设备虽然有着不担心机械运动损坏的优点，但是其本身的使用寿命都比较短暂。比如，CF卡一般只能写100万次。而SD更短，只有10万次。对于像数码相机这样的应用，也许是足够的。但是对于需要频繁擦写磁盘的应用，比如历史数据库，磁盘的损坏问题会很快显现。比如有一个应用式每天向CF卡上写一个16M的文件，文件系统是FAT16, 每簇大小是2K，那么写完这个16M的文件，分区表需要写8192次，于是一个100万次寿命的CF实际能够工作的时间是1000000/8192 = 122天。而损坏的时候，CF卡的其他绝大部分地方的使用次数不过万分之一。</p><p>除了因为静态的文件分区表等区块被频繁的读写而提前损坏，一些嵌入式设备还要面对直接断电的挑战，这会在存储设备上产生不完整的数据。</p><h3 id="2-5-1-损耗均衡"><a href="#2-5-1-损耗均衡" class="headerlink" title="2.5.1. 损耗均衡"></a>2.5.1. 损耗均衡</h3><p>损耗均衡的基本思路是平均地使用存储器上的各个区块。需要维护一张存储器区块使用情况的表，这个表包括区块的偏移位置，当前是否可用，以及已经擦写地次数。当有新的擦写请求的时候，根据以下原则选择区块：</p><ol><li>尽量连续</li><li>擦写次数最少</li></ol><p>即使是更新已经存在的数据，也会使用以上原则分配新的区块。同样，这张表的存放位置也不能是固定不变的，否则这张表所占据的区块就会最先损坏。当要更新这张表的时候，同样要使用以上算法分配区块。</p><p>如果存储器上有大量的静态数据，那么上述算法就只能针对剩下的空间生效，这种情况下还要实现对这些静态数据的搬运的算法。但是这种算法会降低写操作的性能，也增加了算法的复杂度。一般都只使用动态均衡算法。</p><p>目前比较成熟的损耗均衡的文件系统有JFFS2, 和 YAFFS。也有另一种思路就是在FAT16等传统文件系统上实现损耗均衡，只要事先分配一块足够大的文件，在文件内部实现损耗均衡算法。不过必须修改FAT16的代码，关闭对最后修改时间的更新。</p><p>现在的CF卡和SD卡有的已经在内部实现了损耗均衡，这种情况下就不需要软件实现了。</p><h3 id="2-5-2-错误恢复"><a href="#2-5-2-错误恢复" class="headerlink" title="2.5.2. 错误恢复"></a>2.5.2. 错误恢复</h3><p>如果在向存储器写数据的时候发生断电或者被拔出，那么所写的区域的数据就处于未知的状态。在一些应用中，这会导致不完整的文件，而在另一些应用中，则会导致系统失败。所以对这类错误的恢复也是嵌入式软件设计必须考虑的。常用的思路有两种：</p><ol><li>日志型的文件系统</li></ol><p>这种文件系统并不是直接存储数据，而是一条条的日志，所以当发生断电的时候，总可以恢复到之前的状态。这类文件系统的代表如ext3。</p><ol><li>双备份</li></ol><p>双备份的思路更简单，所有的数据都写两份。每次交替使用。文件分区表也必须是双备份的。假设有数据块A，A1是他的备份块，在初始时刻和A的内容是一致的。在分区表中，F指向数据块A，F1是他的备份块。当修改文件时，首先修改数据块A1的内容，如果此时断电，A1的内容错误，但因为F指向的是完好的A，所以数据没有损坏。如果A1修改成功，则修改F1的内容，如果此时断电，因为F是完好的，所以依然没有问题。</p><p>现在的Flash设备，有的已经内置错误检测和错误校正技术，可以保证在断电时数据的完整。还有的包括自动的动态/静态损耗均衡算法和坏块处理，完全无须上层软件额外对待，可以当作硬盘使用。所以，硬件越发达，软件就会越可靠，技术不断的进步，将让我们可以把更多的精力投入到软件功能的本身，这是发展的趋势。</p><p>2.6. 故障成本高昂</p><p>嵌入式产品都是软硬件一起销售的给用户的，所以这带来了一个纯软件所不具备的问题，那就是当产品发生故障时，如果需要返厂才能修复，则成本就很高。嵌入式设备常见有以下的几类故障：</p><p>a) 数据故障。由于某些原因导致数据不能读出或者不一致。比如断电引起的数据库错误。</p><p>b) 软件故障。软件本身的缺陷，需要通过发布补丁程序或者新版本的软件修正。</p><p>c) 系统故障。比如用户下载了错误的系统内核，导致系统无法启动。</p><p>d) 硬件故障。这种故障只有返厂，不属于我们的讨论范围。</p><p>针对前三类故障，要尽可能保证客户自己，或者现场技术人员就可以解决。从架构的角度考虑，如下原则可以参考：</p><p>a) 使用具备错误恢复能力的数据管理设计。当数据发生错误时，用户可以接受的处理依次是：</p><p>i. 错误被纠正，所有数据有效</p><p>ii. 错误发生时的数据（可能不完整）丢失，之前的数据有效。</p><p>iii. 所有数据丢失</p><p>iv. 数据引擎崩溃无法继续工作</p><p>一般而言，满足第二个条件即可。(日志，事务，备份，错误识别)</p><p>b) 将应用程序和系统分离。应用程序应该放置在可插拔的Flash卡上，可以通过读卡器进行文件复制升级。非必要的情况不要使用专用应用软件来升级应用程序。</p><p>c) 要有“安全模式”。即当主系统被损坏后，设备依然可以启动，重新升级系统。常见的uboot可以保证这一点，在系统损坏后，可以进入uboot通过tftp重新升级。</p><h2 id="3-软件框架"><a href="#3-软件框架" class="headerlink" title="3. 软件框架"></a>3. 软件框架</h2><p>在桌面系统和网络系统上，框架是普遍应用的，比如著名的ACE, MFC, Ruby On Rails等。而在嵌入式系统中，框架则是很少使用的。究其原因，大概是认为嵌入式系统简单，没有重复性，过于注重功能的实现和性能的优化。在前言中我们已经提到，现在的嵌入式发展趋势是向着复杂化，大型化，系列化发展的。所以，在嵌入式下设计软件框架也是很有必要，也很有价值的。</p><h3 id="3-1-嵌入式软件架构面临的问题"><a href="#3-1-嵌入式软件架构面临的问题" class="headerlink" title="3.1. 嵌入式软件架构面临的问题"></a>3.1. 嵌入式软件架构面临的问题</h3><p>前面我们讲到，嵌入式系统软件架构所面临的一些问题，其中很重要的一点是，对硬件的依赖和硬件相关软件的复杂性。还包括嵌入式软件在稳定性和内存占用等方面的苛刻要求。如果团队中的每个人都是这些方面高手的话，也许有可能开发出高质量的软件，但事实是一个团队中可能只有一两个资深人员，其他大部分都是初级工程师。人人都去和硬件打交道，都负责稳定性，性能等等指标的话，是很难保证最终产品质量的。如果组件团队时都是精通硬件等底层技术的人才，又很难设计出在可用性，扩展性等方面出色的软件。术业有专攻，架构师的选择决定着团队的组成方式。</p><p>同时，嵌入式软件开发虽然复杂，但是也存在大量的重用的可能性。如何重用，又如何应对将来的变更？</p><p>所以，如何将复杂性对大多数人屏蔽，如何将关注点分离，如何保证系统的关键非功能指标，是嵌入式软件架构设计师应该解决的问题。一种可能的解决方案就是软件框架。</p><h3 id="3-2-什么是框架"><a href="#3-2-什么是框架" class="headerlink" title="3.2. 什么是框架"></a>3.2. 什么是框架</h3><p>框架是在一个给定的问题领域内，为了重用和应对未来需求变化而设计的软件半成品。框架强调对特定领域的抽象，包含大量的专业领域知识，以缩短软件的开发周期，提高软件质量为目的。使用框架的二次开发者通过重写子类或组装对象的方式来实现特殊的功能。</p><h4 id="3-2-1-软件复用的层次"><a href="#3-2-1-软件复用的层次" class="headerlink" title="3.2.1. 软件复用的层次"></a>3.2.1. 软件复用的层次</h4><p>复用是在我们经常谈到的话题，“不要重复发明轮子”也是耳熟能详的戒条。不过对于复用的理解实际上是有很多个层次的。</p><p>最基础的复用是复制粘贴。某个功能以前曾经实现过，再次需要的时候就复制过来，修改一下就可以使用。经验丰富的程序员一般都会有自己的程序库，这样他们实现的时候就会比新的程序员快。复制粘贴的缺点是代码没有经过抽象，往往并不完全的适用，所以需要进行修改，经过多次复用后，代码将会变得混乱，难以理解。很多公司的产品都有这个问题，一个产品的代码从另一个产品复制而来，修改一下就用，有时候甚至类名变量名都不改。按照“只有为复用设计的代码才能真正复用”的标准，这称不上是复用，或者说是低水平的复用。</p><p>更高级的复用是则是库。这种功能需要对经常使用的功能进行抽象，提取出其中恒定不变的部分，以库的形式提供给二次开发程序员使用。因为设计库的时候不知道二次开发者会如何使用，所以对设计者有着很高的要求。这是使用最广泛的一种复用，比如标准C库，STL库。现在非常流行的Python语言的重要优势之一就是其库支持非常广泛，相反C++一直缺少一个强大统一的库支持，成为短板。在公司内部的开发中总结常用功能并开发成库是很有价值的，缺点是对库的升级会影响到很多的产品，必须慎之又慎。</p><p>框架是另一种复用。和库一样，框架也是对系统中不变的部分进行抽象并加以实现，由二次开发者实现其他变化的部分。典型的框架和库的最大的区别是，库是静态的，由二次开发者调用的；框架是活着的，它是主控者，二次开发者的代码必须符合框架的设计，由框架决定在何时调用。</p><p>举个例子，一个网络应用总是要涉及到连接的建立，数据收发和连接的关闭。以库的形式提供是这样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conn = connect(host,port);</span><br><span class="line">if(conn.isvalid())</span><br><span class="line">{</span><br><span class="line">  data = conn.recv();</span><br><span class="line">  printf(data);</span><br><span class="line">  conn.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>框架则是这样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class mycomm:class connect</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">  host();</span><br><span class="line">  port();</span><br><span class="line">  onconnected();</span><br><span class="line">  ondataarrived(unsigned char* data, int len);</span><br><span class="line">  onclose();</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div><p>框架会在“适当”的时机创建mycomm对象，并查询host和port，然后建立连接。在连接建立后，调用onconnected()接口，给二次开发者提供进行处理的机会。当数据到达的时候调用ondataarrived接口让二次开发者处理。这是好莱坞原则，“不要来找我们，我们会去找你”。</p><p>当然，一个完整的框架通常也要提供各种库供二次开发者使用。比如MFC提供了很多的库，如CString, 但本质上它是一个框架。比如实现一个对话框的OnInitDialog接口，就是由框架规定的。</p><h3 id="3-2-2-针对高度特定领域的抽象"><a href="#3-2-2-针对高度特定领域的抽象" class="headerlink" title="3.2.2. 针对高度特定领域的抽象"></a>3.2.2. 针对高度特定领域的抽象</h3><p>和库比较起来，框架是更针对特定领域的抽象。库，比如C库，是面向所有的应用的。而框架相对来说则要狭窄的多。比如MFC提供的框架只适合于Windows平台的桌面应用程序开发，ACE则是针对网络应用开发的框架，Ruby On Rails是为快速开发web站点设计的。</p><p>越是针对特定的领域，抽象就可以做的越强，二次开发就可以越简单，因为共性的东西越多。比如我们上面谈到嵌入式系统软件开发的诸多特点，这就是特定领域的共性，就属于可以抽象的部分。具体到实际的嵌入式应用，又会有更多的共性可以抽象。</p><p>框架的设计目的是总结特定领域的共性，以框架的方式实现，并规定二次开发者的实现方式，从而简化开发。相应的，针对一个领域开发的框架就不能服务于另一个领域。对企业而言，框架是一种极好的积累知识，降低成本的技术手段。</p><h3 id="3-2-3-解除耦合和应对变化"><a href="#3-2-3-解除耦合和应对变化" class="headerlink" title="3.2.3. 解除耦合和应对变化"></a>3.2.3. 解除耦合和应对变化</h3><p>框架设计的一个重要目的就是应对变化。应对变化的本质就是解耦。从架构师的角度看，解耦可以分为三种：</p><ol><li>逻辑解耦。逻辑解耦是将逻辑上不同的模块抽象并分离处理。如数据和界面的解耦。这也是我们最常做的解耦。</li><li>知识解耦。知识解耦是通过设计让掌握不同知识的人仅仅通过接口工作。典型的如测试工程师所掌握的专业知识和开发工程师所掌握的程序设计和实现的知识。传统的测试脚本通常是将这二者合二为一的。所以要求测试工程师同时具备编程的能力。通过适当的方式，可以让测试工程师以最简单的方式实现他的测试用例，而开发人员编写传统的程序代码来执行这些用例。</li><li>变与不变的解耦。这是框架的重要特征。框架通过对领域知识的分析，将共性，也就是不变的内容固定下来，而将可能发生变化的部分交给二次开发者实现。</li></ol><h3 id="3-2-4-框架可以实现和规定非功能性需求"><a href="#3-2-4-框架可以实现和规定非功能性需求" class="headerlink" title="3.2.4. 框架可以实现和规定非功能性需求"></a>3.2.4. 框架可以实现和规定非功能性需求</h3><p>非功能性需求是指如性能，可靠性，可测试性，可移植性等。这些特性可以通过框架来实现。以下我们一一举例。</p><p>性能。对性能的优化最忌讳的就是普遍优化。系统的性能往往取决于一些特定的点。比如在嵌入式系统中，对存储设备的访问是比较慢的。如果开发者不注意这方面的问题，频繁的读写存储设备，就会造成性能下降。如果对存储设备的读写由框架设计，二次开发者只作为数据的提供和处理者，那么就可以在框架中对读写的频率进行调节，从而达到优化性能的目的。由于框架都是单独开发的，完成后供广泛使用，所以就有条件对关键的性能点进行充分的优化。</p><p>可靠性。以上面的网络通讯程序为例，由于框架负责了连接的创建和管理，也处理了各种可能的网络错误，具体的实现者无须了解这方面的知识，也无须实现这方面错误处理的代码，就可以保证整个系统在网络通讯方面的可靠性。以框架的方式设计在可靠性方面的最大优势就是：二次开发的代码是在框架的掌控之内运行的。一方面框架可以将容易出错的部分实现，另一方面对二次开发的代码产生的错误也可以捕获和处理。而库则不能代替使用者处理错误。</p><p>可测试性。可测试性是软件架构需要考虑的一个重要方面。下面的章节会讲到，软件的可测试性是由优良的设计来保证的。一方面，由于框架规定了二次开发的接口，所以可以迫使二次开发者开发出便于进行单元测试的代码。另一方面，框架也可以在系统测试的层面上提供易于实现自动化测试和回归测试的设计，例如统一提供的TL1接口。</p><p>可移植性。如果软件的可移植性是软件设计的目标，框架设计者可以在设计阶段来保证这一点。一种方式是通过跨平台的库来屏蔽系统差异，另一种可能的方式更加极端，基于框架的二次开发可以是脚本化的。组态软件是这方面的一个例子，在PC上组态的工程，也可以在嵌入式设备上运行。</p><h2 id="3-3-一个框架设计的实例"><a href="#3-3-一个框架设计的实例" class="headerlink" title="3.3. 一个框架设计的实例"></a>3.3. 一个框架设计的实例</h2><h3 id="3-3-1-基本架构"><a href="#3-3-1-基本架构" class="headerlink" title="3.3.1. 基本架构"></a>3.3.1. 基本架构</h3><h3 id="3-3-2-功能特点"><a href="#3-3-2-功能特点" class="headerlink" title="3.3.2. 功能特点"></a>3.3.2. 功能特点</h3><p>上面是一个产品系列的架构图，其特点是硬件部分是模块化的，可以随时插拔。不同的硬件应用于不同的通讯测试场合。比如光通讯测试，xDSL测试，Cable Modem测试等等。针对不同的硬件，需要开发不同的固件和软件。固件层的功能主要是通过USB接口接收来自软件的指令，并读写相应的硬件接口，再进行一些计算后，将结果返回给软件。软件运行在WinCE平台，除了提供一个触摸式的图形化界面外，还对外提供基于XML(SOAP)接口和TL1接口。为了实现自动化测试，还提供了基于Lua的脚本语言接口。整个产品系列有几十个不同的硬件模块，相应的需要开发几十套软件。这些软件虽然服务于不同的硬件，但是彼此之间有着高度的相似性。所以，选择先开发一个框架，再基于框架开发具体的模块软件成了最优的选择。</p><p>###　3.3.3. 分析</p><p>软件部分的结构分析如下：</p><p>系统分为软件，固件和硬件三大块。软件和固件运行在两块独立的板子上，有各自的处理器和操作系统。硬件则插在固件所在的板子上，是可以替换的。</p><p>软件和固件其实都是软件，下面我们分别分析。</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>软件的主要工作是提供各种用户界面。包括本地图形化界面，SOAP访问界面，TL1访问界面。</p><p>整个软件部分分为五大部分：</p><ul><li>通讯层</li><li>协议层</li><li>图形界面</li><li>SOAP服务器</li><li>TL1服务器</li></ul><p>通讯层要屏蔽用户对具体通信介质和协议的了解，无论是USB还是socket，对上层都不产生影响。通讯层负责提供可靠的通讯服务和适当的错误处理。通过配置文件,用户可以改变所使用的通讯层。</p><p>协议层的目的是将数据进行编码和解码。编码的产生物是可以在通讯层发送的流，按照嵌入式软件的特点，我们选择二进制作为流的格式。解码的产生物是多种的，既有供界面使用的C Struct，也可以是XML数据，还可以是Lua的数据结构(tablegt)。如果需要，还可以产生JSON,TL1,Python数据,TCL数据等等。这一层在框架中是通过机器自动生成的，我们后面会讲到。</p><p>内存数据库，SOAP Server和TL1 Server都是协议层的用户。图形界面通过读写内存数据库和底层通讯。</p><p>图形界面是框架设计的重点之一，原因是这里工作量最大，重复而无聊的工作最多。</p><p>让我们分析一下在图形界面开发工作中最主要的事情是什么。</p><ol><li>收集用户输入的数据和命令</li><li>将数据和命令发给底层</li><li>接收底层反馈</li><li>将数据显示在界面上</li></ol><p>同时有一些库用来进一步简化开发：</p><p>这是一个简化的例子，但是很好的说明了框架的特点：</p><ol><li>客户代码必须按照规定的接口实现</li><li>框架在适当的时候调用客户实现的接口</li><li>每个接口都被设计为只完成特定的单一功能</li><li>将各个步骤有机的串起来是框架的事，二次开发者不知道，也无须知道。</li><li>通常都要有附带的库。</li></ol><h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><p>固件的主要工作是接受来自软件的命令，驱动硬件工作；获取硬件的状态，进行一定的计算后返回给软件。早期的固件是很薄的一层，因为绝大部分工作是由硬件完成的，固件只起到一个中转通讯的作用。随着时代发展，现在的固件开始承担越来越多原来由硬件完成的工作。</p><p>整个固件部分分为五大部分：</p><p>硬件抽象层，提供对硬件的访问接口</p><p>互相独立的任务群</p><p>任务/消息派发器</p><p>协议层</p><p>通讯层</p><p>针对不同的设备，工作量集中在硬件抽象层和任务群上。硬件抽象层是以库的形式提供的，由对硬件最熟悉，经验最丰富的工程师来实现。任务群则由一系列的任务组成，他们分别代表不同的业务应用。比如测量误码率。这部分由相对经验较少的工程师来实现，他们的主要工作是实现规定的接口，按照标准化文档定义的方式实现算法。</p><p>任务定义了如下接口，由具体开发者来实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OnInit();</span><br><span class="line">OnRegisterMessage();</span><br><span class="line">OnMessageArrive();</span><br><span class="line">Run();</span><br><span class="line">OnResultReport();</span><br></pre></td></tr></tbody></table></figure></div><p>框架的代码流程如下：（伪代码）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CTask* task = new CBertTask();</span><br><span class="line">task->OnInit();</span><br><span class="line">task->OnRegisterMessage();</span><br><span class="line">while(TRUE)</span><br><span class="line">{</span><br><span class="line">  task->OnMessageArrive();</span><br><span class="line">  task->Run();</span><br><span class="line">  task->OnResultReport();</span><br><span class="line">}</span><br><span class="line">delete task;</span><br><span class="line">task = NULL;</span><br></pre></td></tr></tbody></table></figure></div><p>这样，具体任务的实现者所关注的最重要的事情就是实现这几个接口。其他如硬件的初始化，消息的收发，编码解码，结果的上报等等事情都由框架进行了处理。避免了每个工程师都必须处理从上到下的所有方面。并且这样的任务代码还有很高的重用性,比如是在以太网上还是在Cable Modem上实现PING的算法都是一样的。</p><h3 id="3-3-4-实际效果"><a href="#3-3-4-实际效果" class="headerlink" title="3.3.4. 实际效果"></a>3.3.4. 实际效果</h3><p>在实际项目中，框架大大降低了开发难度。对软件部分尤其明显，由实习生即可完成高质量的界面开发，开发周期缩短50%以上。产品质量大大提升。对固件部分的贡献在于降低了对精通底层硬件的工程师的需要，一般的工程师熟知测量算法即可。同时，框架的存在保证了性能，稳定和可测试性等要素。</p><h2 id="3-4-框架设计中的常用模式"><a href="#3-4-框架设计中的常用模式" class="headerlink" title="3.4. 框架设计中的常用模式"></a>3.4. 框架设计中的常用模式</h2><h3 id="3-4-1-模板方法模式"><a href="#3-4-1-模板方法模式" class="headerlink" title="3.4.1. 模板方法模式"></a>3.4.1. 模板方法模式</h3><p>模板方法模式是框架中最常用的设计模式。其根本的思路是将算法由框架固定，而将算法中具体的操作交给二次开发者实现。例如一个设备初始化的逻辑，框架代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TBool CBaseDevice::Init()</span><br><span class="line">{</span><br><span class="line">  if ( DownloadFPGA() != KErrNone )</span><br><span class="line">  {</span><br><span class="line">    LOG(LOG_ERROR,_L(“Download FPGA fail”));</span><br><span class="line">    return EFalse;</span><br><span class="line">  }</span><br><span class="line">  if ( InitKeyPad() != KerrNone )</span><br><span class="line">  {</span><br><span class="line">    LOG(LOG_ERROR,_L(“Initialize keypad fail”));</span><br><span class="line">    return EFalse;</span><br><span class="line">  }</span><br><span class="line">  return ETrue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>DownloadFPGA和InitKeyPad都是CBaseDevice定义的虚函数，二次开发者创建一个继承于CBaseDevice的子类，具体来实现这两个接口。框架定义了调用的次序和错误的处理方式，二次开发者无须关心，也无权决定。</p><h3 id="3-4-2-创建型模式"><a href="#3-4-2-创建型模式" class="headerlink" title="3.4.2. 创建型模式"></a>3.4.2. 创建型模式</h3><p>由于框架通常都涉及到各种不同子类对象的创建，创建型模式是经常使用的。例如一个绘图软件的框架，有一个基类定义了图形对象的接口，基于它可以派生出椭圆，矩形，直线各种子类。当用户绘制一个图形时，框架就要实例化该子类。这时候可以用工厂方法，原型方法等等。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CDrawObj</span><br><span class="line">{</span><br><span class="line">  public:</span><br><span class="line">    virtual int DrawObjTypeID()=0;</span><br><span class="line">    virtual Icon GetToolBarIcon()=0;</span><br><span class="line">    virtual void Draw(Rect rect)=0;</span><br><span class="line">    virtual CDrawObj* Clone()=0;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div><h3 id="3-4-3-消息订阅模式"><a href="#3-4-3-消息订阅模式" class="headerlink" title="3.4.3. 消息订阅模式"></a>3.4.3. 消息订阅模式</h3><p>消息订阅模式是最常用的分离数据和界面的方式。界面开发者只需要注册需要的数据，当数据变化时框架就会将数据“推”到界面。界面开发者可以无须关注数据的来源和内部组织形式。</p><p>消息订阅模式最常见的问题是同步模式下如何处理重入和超时。作为框架设计者，一定要考虑好这个问题。所谓重入，是二次开发者在消息的回调函数中执行订阅/取消订阅的操作，这会破坏消息订阅的机制。所谓超时是指二次开发者的消息回调函数处理时间过长，导致其他消息无法响应。最简单的办法是使用异步模式，让订阅者和数据发布者在独立进程/线程中运行。如果不具备此条件，则必须作为框架的重要约定，禁止二次开发者产生此类问题。</p><h3 id="3-4-4-装饰器模式"><a href="#3-4-4-装饰器模式" class="headerlink" title="3.4.4. 装饰器模式"></a>3.4.4. 装饰器模式</h3><p>装饰器模式赋予了框架在后期增加功能的能力。框架定义装饰器的抽象基类，而由具体的实现者实现，动态地添加到框架中。</p><p>举一个游戏中的例子，图形绘制引擎是一个独立的模块，比如可以绘制人物的静止，跑动等图像。如果策划决定在游戏中增加一种叫“隐身衣”的道具，要求穿着此道具的玩家在屏幕上显示的是若有若无的半透明图像。应该如何设计图像引擎来适应后期的游戏升级呢？</p><p>当隐身衣被装备后，就向图像引擎添加一个过滤器。这是个极度简化的例子，实际的游戏引擎要比这个复杂。装饰器模式还常见用于数据的前置和后置处理上。</p><h2 id="3-5-框架的缺点"><a href="#3-5-框架的缺点" class="headerlink" title="3.5. 框架的缺点"></a>3.5. 框架的缺点</h2><p>一个好的框架可以大大提高产品的开发效率和质量，但也有它的缺点。</p><ol><li>框架一般都比较复杂，设计和实现一个好的框架需要相当的时间。所以，一般只有在框架可以被多次反复应用的时候适合，这时候，前提投入的成本会得到丰厚的回报。</li><li>框架规定了一系列的接口和规则，这虽然简化了二次开发工作，但同时也要求二次开发者必须记住很多规定，如果违反了这些规定，就不能正常工作。但是由于框架屏蔽了大量的领域细节，相对而言，其学习成本还是大大降低了的。</li><li>框架的升级对已有产品可能会造成严重的影响，导致需要完整的回归测试。对这个问题有两个办法。第一是对框架本身进行严格的测试，有必要建立完善的单元测试库，同时开发示例项目，用来测试框架的所有功能。第二则是使用静态链接，让已有产品不轻易跟随升级。当然，如果已有产品有较好的回归测试手段，就更好。</li><li>性能损失。由于框架对系统进行了抽象，增加了系统的复杂性。诸如多态这样的手段使用也会普遍的降低系统的性能。但是从整体上来看，框架可以保证系统的性能处于一个较高的水平。</li></ol><h2 id="4-自动代码生成"><a href="#4-自动代码生成" class="headerlink" title="4. 自动代码生成"></a>4. 自动代码生成</h2><h3 id="4-1-机器能做的事就不要让人来做"><a href="#4-1-机器能做的事就不要让人来做" class="headerlink" title="4.1. 机器能做的事就不要让人来做"></a>4.1. 机器能做的事就不要让人来做</h3><p>懒惰是程序员的美德，更是架构师的美德。软件开发的过程就是人告诉机器如何做事的过程。如果一件事情机器自己就可以做，那就不要让人来做。因为机器不仅不知疲倦，而且绝不会犯错。我们的工作是让客户的工作自动化，多想一点，就能让我们自己的工作也部分自动化。极有耐心的程序员是好的，也是不好的。</p><p>经过良好设计的系统，往往会出现很多高度类似而且具有很强规律的代码。未经良好设计的系统则可能对同一类功能产生很多不同的实现。前面关于框架设计的部分已经证明了这一点。有时候，我们更进一步，分析出这些相似代码之中的规律，用格式化的数据来描述这些功能，而由机器来产生代码。</p><h3 id="4-2-举例"><a href="#4-2-举例" class="headerlink" title="4.2. 举例"></a>4.2. 举例</h3><h4 id="4-2-1-消息的编码和解码"><a href="#4-2-1-消息的编码和解码" class="headerlink" title="4.2.1. 消息的编码和解码"></a>4.2.1. 消息的编码和解码</h4><p>上面关于框架的实例中，可以看到消息编解码的部分已经被独立出来，和其他部分没有耦合。加上他本身的特点，非常适合进一步将其“规则化”，用机器产生代码。</p><p>编码，就是把数据结构流化；解码反之。以编码为例，代码无非是这样的：(二进制协议)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream << a.i;</span><br><span class="line">stream << a.j;</span><br><span class="line">stream << a.object;</span><br></pre></td></tr></tbody></table></figure></div><p>(为了简化，这里假设已经设计了一个流对象，可以流化各种数据类型，并且已经处理了诸如字节序转换等问题。)</p><p>最后我们得到一个stream。大家是否已经习惯了写这种代码？但是这样的代码不能体现工程师任何的创造性，因为我们早已经知道有i, 有j, 还有一个object，为什么还要自己敲入这些代码呢？如果我们分析一下a的定义，是不是就可以自动产生这样的代码呢？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct dataA</span><br><span class="line">{</span><br><span class="line">  int i;</span><br><span class="line">  int j;</span><br><span class="line">  struct dataB object;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div><p>只需要一个简单的语义分析器解析这段代码，得到一棵关于数据类型的树，就可以轻易的产生流化的代码。这样的分析器用Python等字符串处理能力强的语言不过两百行左右。关于数据类型的树类似下图：</p><p>只要遍历这棵树，就可以生成所有数据结构的流化代码。</p><p>在上一个框架所举例的项目中，为一个硬件模块自动产生的消息编码解码器代码量高达三万行，几乎相当于一个小软件。由于是自动产生，没有任何错误，为上层提供了高可靠性。</p><p>还可以用XML或者其他的格式定义数据结构，从而产生自动代码。根据需要，C++/Java/Python，任何类型的都可以。如果希望提供强检查，可以使用XSD来定义数据结构。有一个商业化的产品，xBinder，很贵，很难用，还不如自己开发。(为什么难用？因为它太通用)。除了编码为二进制格式，还可以编码为任何你需要的格式。我们知道二进制格式虽然效率很高，但是太难调试（当然有些人看内存里的十六进制还是很快的），所以我们可以在编码成二进制的同时，还生成编码为其他可阅读的格式的代码，比如XML。这样，通讯使用二进制，而调试使用XML，两全其美。产生二进制的代码大概是这样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xmlbuilder.addelement(“i”,a.i);</span><br><span class="line">Xmlbuilder.addelement(“j”,a.j);</span><br><span class="line">Xmlbuilder.addelement(“object”,a.object);</span><br></pre></td></tr></tbody></table></figure></div><p>同样也很适合机器产生。同样的思路可以用来让软件内嵌脚本支持。这里不多说了。(内嵌脚本支持最大的问题是在C/C++和脚本之间交换数据，也是针对数据类型的大量相似代码。)</p><p>最近Google 发布了它的protocol buffer，就是这样的思路。目前支持C++/Python，估计很快会支持更多的语言，大家可以关注。以后就不要再手写编码解码器了。</p><h3 id="4-2-2-GUI代码"><a href="#4-2-2-GUI代码" class="headerlink" title="4.2.2. GUI代码"></a>4.2.2. GUI代码</h3><p>上面的框架设计部分，我们说到框架对界面数据收集和界面更新无能为力，只能抽象出接口，由程序员具体实现。但是让我们看看这些界面程序员做的事情吧。(代码经过简化，可以看作伪代码)。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void onDataArrive(CDataBinder& data)</span><br><span class="line">{</span><br><span class="line">  m_biterror.setText(“%d”,data.biterror);</span><br><span class="line">  m_signallevel.setText(“%d”,data.signallevel”);</span><br><span class="line">  m_latency.setText(“%d”,data.latency”);</span><br><span class="line">}</span><br><span class="line">Void onCollectData(CDataBinder& data)</span><br><span class="line">{</span><br><span class="line">  data.biterror = atoi(m_biterror.getText());</span><br><span class="line">  data. signallevel = atoi(m_ signallevel.getText());</span><br><span class="line">  data. latency = atoi(m_ latency.getText());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这样的代码很有趣吗？想想我们可以怎么做？（XML描述界面，问题是对于复杂逻辑很难）</p><h3 id="4-2-3-小结"><a href="#4-2-3-小结" class="headerlink" title="4.2.3. 小结"></a>4.2.3. 小结</h3><p>由此可见，在软件架构的过程中，首先要遵循一般性的原则，尽量将系统各个功能部分独立出来，实现高内聚低耦合，进而发现系统存在的高度重复，规律性很强的代码，进一步将他们规则化，形式化，最后用机器来产生这些代码。目前这方面最成功的应用就是消息的编解码。对界面代码的自动化生成有一定局限，但也可以应用。大家在自己的工作中要擅于发现这样的可能，减少工作量，提高工作效率。</p><h3 id="4-2-4-Google-Protocol-Buffer"><a href="#4-2-4-Google-Protocol-Buffer" class="headerlink" title="4.2.4. Google Protocol Buffer"></a>4.2.4. Google Protocol Buffer</h3><p>Google刚刚发布的Protocol Buffer是使用代码自动生成的一个典范。</p><p>Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. You can even update your data structure without breaking deployed programs that are compiled against the “old” format.</p><p>你要做的首先是定义消息的格式，Google指定了它的格式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message Person {</span><br><span class="line">  required string name = 1;</span><br><span class="line">  required int32 id = 2;</span><br><span class="line">  optional string email = 3;</span><br><span class="line">  enum PhoneType {</span><br><span class="line">  MOBILE = 0;</span><br><span class="line">  HOME = 1;</span><br><span class="line">  WORK = 2;</span><br><span class="line">}</span><br><span class="line">message PhoneNumber {</span><br><span class="line">  required string number = 1;</span><br><span class="line">  optional PhoneType type = 2 [default = HOME];</span><br><span class="line">}</span><br><span class="line">  repeated PhoneNumber phone = 4;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>Once you’ve defined your messages, you run the protocol buffer compiler for your application’s language on your .proto file to generate data access classes. These provide simple accessors for each field (like query() and set_query()) as well as methods to serialize/parse the whole structure to/from raw bytes – so, for instance, if your chosen language is C++, running the compiler on the above example will generate a class called Person. You can then use this class in your application to populate, serialize, and retrieve Person protocol buffer messages. You might then write some code like this:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person person;</span><br><span class="line">person.set_name("John Doe");</span><br><span class="line">person.set_id(1234);</span><br><span class="line">person.set_email("jdoe@example.com");</span><br><span class="line">fstream output("myfile", ios::out | ios::binary);</span><br><span class="line">person.SerializeToOstream(&output);</span><br><span class="line">Then, later on, you could read your message back in:</span><br><span class="line">fstream input("myfile", ios::in | ios::binary);</span><br><span class="line">Person person;</span><br><span class="line">person.ParseFromIstream(&input);</span><br><span class="line">cout << "Name: " << person.name() << endl;</span><br><span class="line">cout << "E-mail: " << person.email() << endl;</span><br></pre></td></tr></tbody></table></figure></div><p>Protocol Buffer的编码格式是二进制的，同时也提供可读的文本格式。效率高，体积小，上下兼容。目前支持Java,Python和C++，很快会支持更多的语言。</p><h2 id="5-面向语言编程-LOP"><a href="#5-面向语言编程-LOP" class="headerlink" title="5. 面向语言编程(LOP)"></a>5. 面向语言编程(LOP)</h2><h3 id="5-1-从自动化代码生成更进一步"><a href="#5-1-从自动化代码生成更进一步" class="headerlink" title="5.1. 从自动化代码生成更进一步"></a>5.1. 从自动化代码生成更进一步</h3><p>面向语言编程的通俗定义是：将特定领域的知识融合到一种专用的计算机语言当中，从而提高人与计算机交流的效率。</p><p>自动化代码生成其实就是面向语言编程。语言不等于是编程语言，可以是图，也可以是表，任何可以建立人和机器之间交流渠道的都是计算机语言。软件开发历史上的一次生产率的飞跃是高级语言的发明。它让我们以更简洁的方式实现更复杂的功能。但是高级语言也有它的缺点，那就是从问题领域到程序指令的过程很复杂。因为高级语言是为通用目的而设计的，所以离问题领域很远。举例来说，要做一个图形界面，我可以跟另一个工程师说：这里放一个按钮，那边放一个输入框，当按下按钮的时候，就在输入框里显示Hello World。我甚至可以随手给他画出来。</p><p>对于我和他直接的交流而言，这已经足够了，5分钟。但是要让转变为计算机能够理解的语言，需要多久？</p><p>如果是汇编语言？(告诉计算机如何操作寄存器和内存)</p><p>如果是C++? (告诉计算机如何在屏幕上绘图，如果响应鼠标键盘消息)</p><p>如果有一个不错的图形界面库？(告诉计算机创建Button,Label对象，管理这些对象，放置这些对象，处理消息)</p><p>如果有一个不错的开发框架+IDE? (用WYSIWYG工具绘制，设计类，类的成员变量，编写消息响应函数)</p><p>如果有一门专门做图形界面开发的语言？</p><p>可以是这样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Label l {Text=””}</span><br><span class="line">Button b{Text=”ok”,action=l.Text=”hello world”}</span><br></pre></td></tr></tbody></table></figure></div><p>通用的计算机语言是基于变量，类，分支，循环，链表，消息这些概念的。这些概念离问题本身有着遥远的距离，而且表达能力非常有限。自然语言表达能力很强，但是歧义和冗余太多，无法格式化标准化。传统的思想告诉我们：计算机语言就是一条条的指令，编程就是写下这些指令。而面向语言编程的思想是，用尽量贴近问题，贴近人的思维的办法来描述问题，从而降低从人的思想到计算机软件转换的难度。</p><p>举一个游戏开发的例子。现在的网络游戏普遍的采用了C++或者C开发游戏引擎。而具体的游戏内容，则是由一系列二次开发工具和语言完成的。地图编辑器就是一种面向游戏的语言。Lua或者类似的脚本则被嵌入到游戏内部，用来编写武器，技能，任务等等。Lua本身不具备独立开发应用程序的能力，然而游戏引擎的设计者通过给Lua提供一系列的，各种层次上的接口，将领域知识密集的赋予了脚本，从而大大提高了游戏二次开发的效率。网络游戏的鼻祖MUD则是设计了LPC来作为游戏的开发语言。MUD的引擎MudOS和LPC之间的关系如图：</p><p>用LPC创建一个NPC的代码类似如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">inherit NPC;</span><br><span class="line">void create()</span><br><span class="line">{</span><br><span class="line">  set_name("菜花蛇", ({ "caihua she", "she" }) );</span><br><span class="line">  set("race", "野兽");</span><br><span class="line">  set("age", 1);</span><br><span class="line">  set("long", "一只青幽幽的菜花蛇，头部呈椭圆形。n");</span><br><span class="line">  set("attitude", "peaceful");</span><br><span class="line">  set("str", 15);</span><br><span class="line">  set("cor", 16);</span><br><span class="line">  set("limbs", ({ "头部", "身体", "七寸", "尾巴" }) );</span><br><span class="line">  set("verbs", ({ "bite" }) );</span><br><span class="line">  set("combat_exp", 100+random(50));</span><br><span class="line">  set_temp("apply/attack", 7);</span><br><span class="line">  set_temp("apply/damage", 4);</span><br><span class="line">  set_temp("apply/defence",6);</span><br><span class="line">  set_temp("apply/armor",5);</span><br><span class="line">  setup();</span><br><span class="line">}</span><br><span class="line">void die()</span><br><span class="line">{</span><br><span class="line">  object ob;</span><br><span class="line">  message_vision("$N抽搐两下，$N死了。n", this_object());</span><br><span class="line">  ob = new(__DIR__"obj/sherou");</span><br><span class="line">  ob->move(environment(this_object()));</span><br><span class="line">  destruct(this_object());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>LPC培养了一大批业余游戏开发者，甚至成为很多人进入IT行业的起点。原因就是它简单，易理解，100%为游戏开发设计。这就是LOP的魅力。</p><h3 id="5-2-优势和劣势"><a href="#5-2-优势和劣势" class="headerlink" title="5.2. 优势和劣势"></a>5.2. 优势和劣势</h3><p>LOP最重要的优点是将领域知识固化到语言中，从而：</p><ol><li>提高开发效率。</li><li>优化团队结构，降低交流成本，领域专家和程序员可以更好的合作。</li><li>降低耦合，易于维护。</li></ol><p>其次，由于LOP不是通用语言，所涉及的范围就狭窄很多，所以：</p><ol><li>更容易得到稳定的系统</li><li>更容易移植</li></ol><p>相应的，LOP也有它的劣势：</p><ol><li>LOP对领域知识抽象的要求比框架更高。</li><li>开发一门新的语言本身的成本。幸好现在设计一门新的语言不算太难，还有Lua这样的“专用二次开发”语言的支持。</li><li>性能损失。不过相比开发成本的节约，在非性能核心部分使用LOP还是很值得的。</li></ol><h3 id="5-3-在嵌入式系统中的应用"><a href="#5-3-在嵌入式系统中的应用" class="headerlink" title="5.3. 在嵌入式系统中的应用"></a>5.3. 在嵌入式系统中的应用</h3><p>举例，嵌入式设备的Web服务器。很多设备都提供Web服务用于配置，比如路由器，ADSL猫等等。这种设备所提供的web服务的典型用例是用户填写一些参数，提交给Web服务器，Web 服务器将这些参数写入硬件，并将操作结果或者其他信息生成页面返回给浏览器。由于典型的Apache,Mysql,PHP组合体积太大且不容易移植，通常嵌入式系统的Web服务都是用C/C++直接写就的。从socket管理，http协议到具体操作硬件，生成页面，都一体负责。然而对于功能复杂，Web界面要求较高的情况，用C来写页面效率就太低了。</p><p>shttpd是一个小巧的web服务器，小巧到只有一个.c文件，4000余行代码。虽然体积很小，却具备了最基本的功能，比如CGI。它既可以独立运行，也可以嵌入到其他的应用程序当中。shttpd在大多数平台上都可以顺利编译、运行。lua是一个小巧的脚本语言，专用于嵌入和扩展。它和C/C++代码有着良好的交互能力。</p><p>将Lua引擎嵌入到shttpd中，再使用C编写一个（一些）驱动硬件的扩展，注册成为Lua的函数，形成的系统结构如下图：</p><p>这样的应用在嵌入式系统中是有一定代表性的，即，以C实现底层核心功能，而把系统的易变部分以脚本实现。大家可以思考在自己的开发过程中是否可以使用这种技术。这是LOP的一种具体应用模式。（没有创造一种全新的语言，而是使用Lua）</p><h2 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h2><h3 id="6-1-可测试性是软件质量的一个度量指标"><a href="#6-1-可测试性是软件质量的一个度量指标" class="headerlink" title="6.1. 可测试性是软件质量的一个度量指标"></a>6.1. 可测试性是软件质量的一个度量指标</h3><p>好的软件是设计出来的，好的软件也一定是便于测试的。一个难于测试的软件的质量是难以得到保障的。在今天软件规模越来越大的趋势下，以下问题是普遍存在的：</p><ol><li>测试只能手工进行，回归测试代价极大，实际只能执行点测，质量无法保证</li><li>各个模块只有集成到一起后才能测试</li><li>代码不经过任何单元测试就集成</li></ol><p>这些问题的根源都在于缺乏一个良好的软件设计。一个好的软件设计应该使得单元测试，模块测试和回归测试都变得容易，从而保证测试的广度和深度，最终产生高质量的软件。除了功能，非功能性需求也必须是可测试的。所以，可测试性是软件设计中一个重要的指标，是系统架构师需要认真考虑的问题。</p><h3 id="6-2-测试驱动的软件架构"><a href="#6-2-测试驱动的软件架构" class="headerlink" title="6.2. 测试驱动的软件架构"></a>6.2. 测试驱动的软件架构</h3><p>这里谈的是测试驱动的软件架构，而不是测试驱动的开发。TDD(Test Driven Development) 是一种开发方式，是一种编码实践。而测试驱动的架构强调的是，从提高可测试性的角度进行架构设计。软件的测试分为多个层次：</p><h3 id="6-3-系统测试"><a href="#6-3-系统测试" class="headerlink" title="6.3. 系统测试"></a>6.3. 系统测试</h3><p>系统测试是指由测试人员执行的，验证软件是否完整正确的实现了需求的测试。这种测试中，测试人员作为用户的角色，通过程序界面进行测试。在大部分情况下这些工作是手工完成的。在规范的流程中，这个过程通常要占到整个软件开发时间的1/3以上。而当有新版本发布的时候，尽管只涉及了软件的一部分，测试部门依然需要完整的测试整个软件。这是由代码“副作用”特点决定的。有时候修改一个bug可以引发更多的bug，破坏原来工作正常的代码。这在测试中叫回归测试(Regression test)。对于规模较大的软件，回归测试需要很长的时间，在版本新增功能和错误修正不多的情况下，回归测试可以占到整个软件开发过程了一半以上，严重影响了软件的交付，也使软件测试部门成为软件开发流程中的瓶颈。测试过程自动化，是部分解决这个问题的办法。</p><p>作为架构师，有必要考虑如何实现软件的可自动化测试性。</p><h4 id="6-3-1-界面自动化测试"><a href="#6-3-1-界面自动化测试" class="headerlink" title="6.3.1. 界面自动化测试"></a>6.3.1. 界面自动化测试</h4><p>在没有图形化界面以前，字符方式的界面是比较容易进行自动化测试的。一个编写良好的脚本就可以实现输入和对输出的检查。但是对于图形化的界面，人的参与似乎变得不可缺少。有一些界面自动化的测试工具，如WinRunner， 这些工具可以记录下测试人员的操作成为脚本，然后通过回放这些脚本，就可以实现操作的自动化。针对嵌入式设备，有Test Quest可以使用，通过在设备中运行一个类似远程桌面的Agent，PC端的测试工具可以用图像识别的方法识别出不同的组件，并发送相应用户的输入。此类工具的基本工作原理如图：</p><p>但是这个过程在实际中存在三个问题：</p><ol><li>可靠性差，经常中断运行。要写一个可靠的脚本甚至比开发软件还要困难。比如，按下一个按钮，有时候一个对话框立刻就出现，有时候可能要好几秒，有时候甚至不出现，操作录制工具不能自动实现这些判断，而需要手动修改。</li><li>对操作结果的判断很困难，尤其是非标准的控件。</li><li>当界面修改后，原有代码很容易失效</li></ol><p>要应用基于图形界面的自动化测试工具，架构师在架构的时候应该考虑：</p><ol><li>界面风格如何保持一致。应当由架构，而非程序员决定架构的风格。包括布局，控件大小，相对位置，文字，对操作的响应方式，超时时长，等等。</li><li>如何在最合适测试工具的界面和用户喜欢的界面之中折中。比如，Test Quest是基于图像识别的，那么黑白两色的界面是最有利的，而用户喜欢的渐进色就非常不利。也许让界面具备自动的切换能力最好。</li></ol><p>对于已经完成的产品，如果架构没有为自动化测试做过考虑，所能应用的范围就非常有限，不过还是有一些思路可以供参考：</p><ol><li>实现小规模的自动化脚本。针对一个具体的操作流程进行测试，而不是试图用一个脚本测试整个软件。一系列的小测试脚本组成了一个集合，覆盖系统的一部分功能。这些测试脚本可以都以软件启动时的状态作为基准，所以在状态处理上会比较简单</li><li>”猴子测试”有一定的价值。所谓猴子测试，就是随机操作鼠标和键盘。这种测试完全不理解软件的功能，可以发现一些正常测试无法发现的错误。据微软内部的资料，微软的一些产品15%的错误是由“猴子测试”发现的。</li></ol><p>总的来讲，基于界面的自动化测试是不成熟的。对架构师而言一定要避免功能只能通过界面才能访问。要让界面仅仅是界面，而软件大部分的功能是独立于界面并可以通过其他方式访问的。上面框架的例子中的设计就体现了这一点。</p><p>思考：如何让界面具有自我测试功能？</p><h4 id="6-3-2-基于消息的自动化测试"><a href="#6-3-2-基于消息的自动化测试" class="headerlink" title="6.3.2. 基于消息的自动化测试"></a>6.3.2. 基于消息的自动化测试</h4><p>如果软件对外提供基于消息的接口，自动化测试就会变得简单的多。上面已经提到了固件的TL1接口。对于界面部分，则应该在设计的时候，将纯粹的“界面”独立出来，让它尽可能的薄，而其他部分依然可以基于消息提供服务。</p><p>在消息的基础上，用脚本语言包装成函数的形式，可以很容易的调用，并覆盖消息的各种参数组合，从而提高测试的覆盖率。关于如何将消息包装为脚本，可以参考SOAP的实现。如果使用的不是XML，也可以自己实现类似的自动代码生成。</p><p>这些测试脚本应该由开发人员撰写，每当实现了一个新的接口（也就是一条新的消息），就应该撰写相应的测试脚本，并作为项目的一部分保存在代码库中。当需要执行回归测试的时候，只要运行一遍测试脚本即可，大大提高了回归测试的效率。</p><p>所以，为了实现软件的自动化测试，提供基于消息的接口是一个很好的办法，这让我们可以在软件之外独立的编写测试脚本。在设计的时候可以考虑这个因素，适当的增加软件消息的支持。当然，TL1只是一个例子，根据项目的需要，可以选择任何适合的协议，如SOAP。</p><h4 id="6-3-3-自动化测试框架"><a href="#6-3-3-自动化测试框架" class="headerlink" title="6.3.3. 自动化测试框架"></a>6.3.3. 自动化测试框架</h4><p>在编写自动化测试脚本的时候，有很多的工作是重复的，比如建立socket连接，日志，错误处理，报表生成等。同时，对于测试人员来说，这些工作可能是比较困难的。因此，设计一个框架，实现并隐藏这些重复和复杂的技术，让测试脚本的编写者将注意力集中在具体的测试逻辑上。</p><p>这样一个框架应该实现以下功能：</p><ol><li>完成连接的初始化等基础工作。</li><li>捕获所有的错误，保证Test Case中的错误不会打断后续的Test Case执行。</li><li>自动检测和执行Test Case。新增的Test Case是独立的脚本文件，无须修改框架的代码或者配置。</li><li>消息编解码，并以函数的方式提供给Test Case编写者调用。</li><li>方便的工具，如报表，日志等。</li><li>自动统计Test Case的运行结果并生成报告。</li></ol><p>自动化测试框架的思路和一般的软件框架是一致的，就是避免重复劳动，降低开发难度。</p><p>下图是一个自动化测试框架的结构图：</p><p>每个Test Case都必须定义一个规定的Run函数，框架将依次调用，并提供相应的库函数供Test Case用来发送命令和获得结果。这样，测试用例的编写者就只需要将注意力集中在测试本身。举例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def run():</span><br><span class="line">  open_laser()</span><br><span class="line">  assert(get_laser_state() == ON)</span><br><span class="line">  insert_error(BIT_ERROR)</span><br><span class="line">  assert(get_error_bit() == BIT_ERROR)</span><br></pre></td></tr></tbody></table></figure></div><p>测试用例的编写者拥有的知识是“必须先打开激光器然后才能向线路上插入错误”。而架构师能提供的是消息收发，编解码，错误处理，报表生成等，并将这些为测试用例编写者隔离。</p><p>问题: open_laser, get_laser_state这些函数是谁写的？</p><p>问题：如何进一步实现知识的解耦？能否有更方便的语言来编写TestCase?</p><h4 id="6-3-4-回归测试"><a href="#6-3-4-回归测试" class="headerlink" title="6.3.4. 回归测试"></a>6.3.4. 回归测试</h4><p>有了自动化的测试脚本和框架，回归测试就变得很简单了。每当有新版本发布时，只需运行一遍现有的Test Case，分析测试报告，如果有测试失败的Case则回归测试失败，需要重新修改，直到所有的Case完全通过。完整的回归测试是软件质量的重要保证。</p><h2 id="6-4-集成测试"><a href="#6-4-集成测试" class="headerlink" title="6.4. 集成测试"></a>6.4. 集成测试</h2><p>集成测试要验证的是系统各个组成模块的接口是否工作正常。这是比系统测试更低层的测试，通常由开发人员和测试人员共同完成。</p><p>例如在一个典型的嵌入式系统中，FPGA，固件和界面是常见的三个模块。模块本身还可以划分为更小的模块，从而降低复杂度。嵌入式软件模块测试的常见问题是硬件没有固件则无法工作，固件没有界面就无法驱动;反过来，界面没有固件不能完整运行，固件没有硬件甚至无法运行。于是没有经过测试的模块直到集成的时候才能完整运行，发现问题后需要考虑所有模块的问题，定位和解决的代价都很大。假设有模块A和B，各有十个bug。如果都没有经过模块测试直接集成，可以认为排错的工作量相当于10*10等于100。</p><p>所以，在设计一个模块的时候，首先要考虑，这个模块如何单独测试？比如，如果界面和固件之间是通过SOCKET通信的，那么就可以开发一个模拟固件，在同样的端口上提供服务。这个模拟固件不执行实际的操作，但是会响应界面的请求并返回模拟的结果。并且返回的结果可以覆盖到各种典型的情况，包括错误的情况。使用这样的技术，界面部分几乎可以得到100%的验证，在集成阶段遇到错误的大大减少。</p><p>对固件而言，因为处于系统的中间，所以问题复杂一些。一方面，要让固件可以通过GUI以外的途径被调用；另一方面则要模拟硬件的功能。对于第一点，在设计的时候，要让接口和实现分离。接口可以随意的更换，比如和GUI的接口也许是JSON，同时还可以提供telnet的TL1接口，但是实现是完全一样的。这样，在和GUI集成之前，就可以通过TL1进行完全的测试固件。对于第二点，则应该在设计的时候提取出硬件抽象层，让固件的主要实现和寄存器，内存地址等因素隔离开来。在没有硬件或者硬件设计未定的时候实现一个硬件模拟层，来保证固件可以完整运行并测试。</p><h2 id="6-5-单元测试"><a href="#6-5-单元测试" class="headerlink" title="6.5. 单元测试"></a>6.5. 单元测试</h2><p>单元测试是软件测试的最基本单位，是由开发人员执行以保证其所开发代码正确的过程。开发人员应该提交经过测试的代码。未经单元测试的代码在进入软件后，不仅发现问题后很难定位，而且通过系统测试是很难做到对代码分支的完全覆盖的。TDD就是基于这个层次的开发模式。</p><p>单元测试的粒度一般是函数或者类，例如下面这个常用函数：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int atoi(const char *nptr);</span><br></pre></td></tr></tbody></table></figure></div><p>这是一个功能非常单一的函数，所以单元测试对它非常有效。可以通过单元测试验证下列情况：</p><ol><li>一般正常调用,如”9”,”1000”,”-1”等</li><li>空的nptr指针</li><li>非数字字符串,”abc”,”@#!123”,”123abc”</li><li>带小数点的字符串, “1.1”,”0.111”,”.123”</li><li>超长字符串</li><li>超大数字，”999999999999999999999999999”</li><li>超过一个的-号和位置错误的-号,”—1”,”-1-“,”-1-2”</li></ol><p>如果atoi通过了以上测试，我们就可以放心的将它集成到软件中去了。由它再引发问题的概率就很小了(不是完全没有，因为我们不能遍历所有可能，只是挑选有代表性的异常情况进行测试)。</p><p>以上的例子可以说是单元测试的典范，但实际中却常常不是这么回事。我们常常发现写好的函数很难做单元测试，不仅工作量很大，效果也不见得好。其根本的原因是，函数没有遵循好一些原则：</p><ol><li>单一功能</li><li>低耦合</li></ol><p>反观atoi的例子，功能单一明确，和其他函数几乎没有任何耦合（我上面并没有写atoi的代码实现，大家可以自己实现，希望是0耦合）。</p><p>下面我举一个实际中的例子。</p><p>这是一个简单的TL1命令发送和解析软件，功能需求描述如下：</p><p>ü 通过telnet与TL1服务器通讯</p><p>ü 发送TL1命令给TL1服务器</p><p>ü 解析TL1服务器的响应</p><p>TL1是通讯行业广泛使用的一种协议，为了给不熟悉TL1的朋友简化问题，我定义了一个简化的格式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CMD:CTAG:PAYLOAD;</span><br><span class="line"></span><br><span class="line">CMD - 命令的名字，可以是任意字母开头，由字母和下划线组成的字符串</span><br><span class="line"></span><br><span class="line">CTAG - 一个数字，用于标志命令的序号</span><br><span class="line"></span><br><span class="line">PAYLOAD - 可以是任意格式的内容</span><br><span class="line"></span><br><span class="line">; - 结束符</span><br><span class="line"></span><br><span class="line">相应的，TL1服务器的回应也有格式：</span><br><span class="line"></span><br><span class="line">DATE</span><br><span class="line"></span><br><span class="line">CTAG COMPLD</span><br><span class="line"></span><br><span class="line">PAYLOAD</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">DATE – 日期和时间</span><br><span class="line"></span><br><span class="line">CTAG – 一个数字，和TL1 命令所携带的CTAG一样</span><br><span class="line"></span><br><span class="line">COMPLD – 表明命令执行成功</span><br><span class="line"></span><br><span class="line">PAYLOAD - 返回的结果，可以是任何格式的内容</span><br><span class="line"></span><br><span class="line">; - 结束符</span><br></pre></td></tr></tbody></table></figure></div><p>举例：</p><p>命令：<code>GET-IP-CONFIG:1:;</code></p><p>结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2008-7-19 11:00:00</span><br><span class="line">1 COMPLD</span><br><span class="line">ip address: 192.168.1.200</span><br><span class="line">gate way: 192.168.1.1</span><br><span class="line">dns: 192.168.1.3</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure></div><p>命令：<code>SET-IP-CONFIG:2:172.31.2.100,172.31.2.1,172.31.2.3;</code></p><p>结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2008-7-19 11:00:05</span><br><span class="line">2 COMPLD</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure></div><p>软件的最上层可能是这样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dict* ipconf = GET_IP_CONFIG();</span><br><span class="line">ipconf->set(“ipaddr”,”172.31.2.100)</span><br><span class="line">ipconf->set(“gateway”,”172.3.2.1”)</span><br><span class="line">ipconf->set(“dns”,”172.31.2.1”)</span><br><span class="line">SET_IP_CONFIG(ipconf);</span><br></pre></td></tr></tbody></table></figure></div><p>以GET_IP_CONFIG为例，这个函数应该完成的功能包括：</p><p>ü 建立telnet连接，如果连接尚未建立</p><p>ü 构造TL1命令字符串</p><p>ü 发送</p><p>ü 接收反馈</p><p>ü 解析反馈，并给IP_CONF结构复制</p><p>ü 返回</p><p>我们当然不希望每个这样的函数都重复实现这些功能，所以我们定义了几个模块：</p><ol><li>Telnet 连接管理</li><li>TL1命令构造</li><li>TL1 结果解析</li></ol><p>这里我们来分析TL1结果解析，假设设计为一个函数，函数的原型如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dict* TL1Parse(const char* tl1response)</span><br></pre></td></tr></tbody></table></figure></div><p>这个函数的功能是接受一个字符串，如果它是一个合法且已知的TL1回应，则将其中的结果提取出来，放入一个字典对象中。</p><p>这本来会是一个很便于进行单元测试的例子：输入各种字符串，检查返回结果是否正确即可。但是在这个软件中，有一个很特殊的问题：</p><p>TL1Parse在解析一个字符串时，它必须要知道当前要处理的是哪条命令的回应。但是请注意，在TL1的回应中，是不包括命令的名字的。唯一的办法是使用CTAG，这个命令和回应一一对应的数字。Tl1Parse首先提取出CTAG来，然后查找使用这个CTAG的是什么命令。这里产生了一个对外调用，也就是耦合。</p><p>有一个对象维护了一个CTAG和命令名字对应关系的表，通过CTAG，可以查询到对应的命令名，从而知道如何解析这个TL1 response.</p><p>如此一来，TL1Parse就无法进行单元测试了，至少不能轻易的进行。通常的桩函数的办法都不好用了。</p><p>怎么办？</p><p>重新设计，消除耦合。</p><p>将TL1Parse拆分为两个函数：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tl1_header TL1_get_header(const char* tl1response)</span><br><span class="line">Dict* TL1_parse_payload(const char* tl1name ,const char* tl1payload)</span><br></pre></td></tr></tbody></table></figure></div><p>这两个函数都可以单独进行完整的单元测试。而这两个函数的代码基本就是TL1Parse切分了一下，但是其可测试性得到了很大的提高，得到一个可靠的解析器的可能性自然也大大提升了。</p><p>这个例子演示了如何通过设计来提高代码的可测试性—这里是单元测试。一个随意设计，随意实现的软件要进行单元测试将会是一场噩梦，只有在设计的时候就考虑到单元测试的需要，才能真正的进行单元测试。</p><h4 id="6-5-1-圈复杂度测量"><a href="#6-5-1-圈复杂度测量" class="headerlink" title="6.5.1. 圈复杂度测量"></a>6.5.1. 圈复杂度测量</h4><p>模块的复杂度直接影响了单元测试的覆盖率。最著名的度量代码复杂度的方法是圈复杂度测量。</p><p>计算公式：V(F)=e-n+2。其中e是流程图中的边的数量，n是节点数量。简单的算法是统计如 if、while、do和switch 中的 case 语句数加1。适合于单元测试的代码的复杂度一般认为不应该超过10。</p><h4 id="6-5-2-扇入扇出测量"><a href="#6-5-2-扇入扇出测量" class="headerlink" title="6.5.2. 扇入扇出测量"></a>6.5.2. 扇入扇出测量</h4><p>扇入是指一个模块被其他模块所引用。扇出是指一个模块引用其他模块。我们都知道好的设计应该是高内聚低耦合的，也就是高扇入低扇出。一个扇出超过7的模块一般认为是设计欠佳的。扇出过大的模块进行单元测试不论从桩设置还是覆盖率上都是困难的。将系统的传出耦合和传入耦合的数量结合起来，形成另一个度量：不稳定性。</p><p>不稳定性 = 扇出 / (扇入 + 扇出)</p><p>这个值的范围从0到1。值越接近1，它就越不稳定。在设计和实现架构时，应当尽量依赖稳定的包，因为这些包不太可能更改。相反的，依赖一个不稳定的包，发生更改时间接受到伤害的可能性就更大。</p><h4 id="6-5-3-框架对单元测试的意义"><a href="#6-5-3-框架对单元测试的意义" class="headerlink" title="6.5.3. 框架对单元测试的意义"></a>6.5.3. 框架对单元测试的意义</h4><p>框架的应用在很大程度上可以帮助进行单元测试。因为二次开发者被限定实现特定的接口，而这些接口势必都是功能明确，简单，低耦合的。之前的框架示例代码也演示了这一点。这再次说明了，由高水平的工程师设计出的框架，可以强制初级工程师产生高质量的代码。</p><h2 id="7-维护架构的一致性"><a href="#7-维护架构的一致性" class="headerlink" title="7. 维护架构的一致性"></a>7. 维护架构的一致性</h2><p>在实际的开发中，代码偏离精心设计的架构是很常见的事情，比如下图示例了一个嵌入式设备中设计的MVC模式：</p><p>View依赖于Controller和Model, Controller依赖于Model，Model作为底层服务提供者，不依赖View或者Controller. 这是一个适用的架构，可以在相当程度上分离业务，数据和界面。但是，某个程序员在实现时，使用了一个从Model到View的调用，破坏了架构。</p><p>这种现象通常发生在产品的维护阶段，有时也发生在架构的实现阶段。为了增加一个功能或者修正一个错误，程序员由于不理解原有架构的思路，或者只是单纯的偷懒，走了“捷径”。如果这样的实现不能及时发现并纠正，设计良好的架构就会被渐渐破坏，也就是我们常说的“架构”腐烂了。通常一个有一定年龄的软件产品的架构都有这个问题。如何监视并防止这种问题，有技术上的和管理上的手段。</p><p>技术上，借助工具，可以对系统组件的依赖进行分析，架构的外在表现最重要的就是各个部分的耦合关系。有一些工具可以统计软件组件的扇入和扇出。可以用这种工具编写测试代码，对组件的扇出进行检测，一旦发现测试失败，就说明架构遭到了破坏。这种检查可以集成在一些IDE中， 在编译时同步进行，或者在check in的时候进行。更高级的工具可以对代码进行反向工程生成UML，可以提供更进一步的信息。但通常对扇入扇出做检查就可以了。</p><p>通过设置代码检视的开发流程，对程序员check in的代码进行评审，也可以防止此类问题。代码检视是开发中非常重要的一环，它属于开发后期阶段用来防止坏的代码进入系统的重要手段。代码检视通常要关注以下问题：</p><ol><li>是否正确完整的完成了需求</li><li>是否遵循了系统的架构</li><li>代码的可测试性</li><li>错误处理是否完备</li><li>代码规范</li></ol><p>代码检视通常以会议的形式进行，时间点设置在项目阶段性完成，需要check in代码时。对于迭代式开发，则可以在一个迭代周期结束前组织。参与人员包括架构师，项目经理，项目成员，其他项目的资深工程师等。一般时间不要太长，以不超过2个小时为宜。会议前2天左右发出会议通知和相关文档代码，与会者必须先了解会议内容，进行准备。会议中，由代码的作者首先讲解代码需要实现的功能，自己的实现思路。然后展示代码。与会者根据自己的经验提出各种问题和改进意见。这种会议最忌讳的是让作者感到被指责或者轻视，所以，会议组织者要首先定义会议的基调：会议成功与否的标准不是作者的代码质量如何，而是与会者是否提供了有益的建议。会后由作者给与会者打分，而不是反之。</p><h2 id="8-一个实际嵌入式系统架构的演化"><a href="#8-一个实际嵌入式系统架构的演化" class="headerlink" title="8. 一个实际嵌入式系统架构的演化"></a>8. 一个实际嵌入式系统架构的演化</h2><p>上世纪九十年代，互联网的极速发展让通讯测试设备也得到了极大的发展。那个年代，能够实现某种测量的硬件是竞争的核心，软件的目的仅仅是驱动硬件运行起来，再提供一个简单的界面。所以，最初的产品的软件结构非常简单，类似前面的城铁门禁系统。</p><p>优点：程序简单明了的实现了用户的需求，一个程序员就可以全部搞定。</p><p>缺点：完全没有划分模块，底层上层耦合严重。</p><h3 id="8-1-数据处理"><a href="#8-1-数据处理" class="headerlink" title="8.1. 数据处理"></a>8.1. 数据处理</h3><p>用户要求能将测量结果保存下来，并可以重新打开。数据存储模块和界面被独立出来。</p><p>依然保持上面的主逻辑，但是界面部分不仅可以显示实时的数据，也可以从ResultManager中读取数据来显示。</p><p>优点：数据和界面分离的雏形初步显现</p><p>缺点：ResultManager只是作为一个工具存在，负责保存和装载历史数据。界面和数据的来源依然耦合的很紧。不同的界面需要的不同数据都是通过硬编码判断的。</p><h3 id="8-2-窗口管理"><a href="#8-2-窗口管理" class="headerlink" title="8.2. 窗口管理"></a>8.2. 窗口管理</h3><p>随着功能不断复杂，界面窗口越来越多，原来靠一个类来绘制各种界面的方式已经不能承受。于是窗口的概念被引入。每个界面都被视为一个窗口，窗口中的元素为控件。窗口的打开，关闭，隐藏则由窗口管理器负责。</p><p>优点：界面功能以窗口的单位分离，不再是一个超大的集合。</p><p>缺点：虽然有了窗口管理器，但是界面依然是直接和底层耦合的，依然是大循环结构。</p><h3 id="8-3-MVC模式"><a href="#8-3-MVC模式" class="headerlink" title="8.3. MVC模式"></a>8.3. MVC模式</h3><p>随着规模进一步扩大，最初的大循环结构终于无法满足日益复杂的需求了。标准的MVC模式被引入，经历了一次大的重构。</p><p>数据中心作为Model被独立出来，保存着当前最新的数据。View被放在了独立的任务中执行，定期从DataCenter轮询数据。用户的操作通过View发送给Controller，进一步调用硬件驱动执行。硬件执行的结果从驱动到Controller更新到DataCenter中。界面，数据，命令三者基本解耦。ResultManager成为DataCenter的一个组件，View不再直接与其通讯。</p><p>MVC模式的引入，第一次让这个产品了有真正意义上职责明晰，功能独立的架构。</p><h3 id="8-4-大量类似模块，低效的复用"><a href="#8-4-大量类似模块，低效的复用" class="headerlink" title="8.4. 大量类似模块，低效的复用"></a>8.4. 大量类似模块，低效的复用</h3><p>到上一步，作为一个单独的嵌入式设备，其架构基本可以满足需求。但是随着市场的扩展，越来越多的设备被设计出来。这些设备虽然执行的具体测量任务不同，但是他们都有着同样的操作方式，类似的界面，更主要的是，它们面临的问题领域是相同的。长期以来，复制和粘贴是唯一的复用方式，甚至类名变量名都来不及改。一个错误在一个设备上被修正，同样一段代码的错误在其他设备上却来不及修改。而随着团队规模的扩大，甚至MVC的基本架构在一些新设备上都没能遵守。</p><p>最终框架被引入了这个系列的产品。框架确定了如下内容：</p><ol><li>MVC模式的基本架构</li><li>窗口管理器和组件布局算法</li><li>多国语言方案（字符串管理器）</li><li>日志系统</li><li>内存分配器和内存泄露检测</li></ol><h2 id="8-5-远程控制"><a href="#8-5-远程控制" class="headerlink" title="8.5. 远程控制"></a>8.5. 远程控制</h2><p>客户希望将设备固定安放在网络的某个位置，作为“探针”使用，在办公室通过远程控制来访问这个设备。这对于原本是作为纯手持设备设计的系统又是一个挑战。幸运的是，MVC架构具有相当的弹性，早期的投入获得了回报。</p><p>TL1 Server 对外提供基于Telnet的远程控制接口。在系统内部，它的位置相当于View，只和原有的Controller和DataCenter通讯。</p><h2 id="8-6-自动化的TL1解释器"><a href="#8-6-自动化的TL1解释器" class="headerlink" title="8.6. 自动化的TL1解释器"></a>8.6. 自动化的TL1解释器</h2><p>由于TL1命令相当多，而TL1又往往不是客户的第一需求，很多设备的TL1命令开始不完整。究其原因，还是手写TL1命令的解释器太累。后来通过引入Bison和Flex，这个问题有所改善，但还是不足。自动化代码生成在这个阶段被引入。通过以如下的格式定义TL1，工具可以自动生成TL1的编码和解码器代码。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CMD_NAME</span><br><span class="line">{</span><br><span class="line">  cmd = “SET-TIME-CONFIG::<ctag>::<year>,<month>,<day>,<hour>,<minute>,[<second>]”</second></minute></hour></day></month></year></ctag></span><br><span class="line">  year = 1970..2100</span><br><span class="line">  month = 1..12</span><br><span class="line">  day = 1..31</span><br><span class="line">  hour = 0..23</span><br><span class="line">  minute = 0..59</span><br><span class="line">  second = 0..59</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="8-7-测试的难题"><a href="#8-7-测试的难题" class="headerlink" title="8.7. 测试的难题"></a>8.7. 测试的难题</h2><p>经过数十年的积累，产品已经成为一个系列，几十种设备。大部分设备进入了维护期，经常有客户提一些小的改进，或者要求修正一下缺陷。繁重的手工回归测试成为了噩梦。</p><p>基于TL1的自动化测试极大的解放了测试人员。通过在PC上运行的测试脚本，回归测试变得简单而可靠。唯一不足的是界面部分无法验证。</p><p>基于Test Quest的自动化工具需要在设备运行的pSOS系统上开发一个类似远程桌面的软件，而这在pSOS上并非易事。不过好消息是，由于框架固定了界面的风格和布局算法，基于Test Quest的自动化工具会有很高的识别效率。</p><h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8. 小结"></a>8.8. 小结</h2><p>从这个实际的嵌入式产品重构的历程可以看出，第三步引入MVC模式和第四步的框架化是非常关键的。成熟的MVC模式保证了后续一系列的可扩充性，而框架则保证了这个架构的在所有产品中的准确重用。</p><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>本文是针对嵌入式软件开发的特点，讨论架构设计的思路和方法。试图给大家提供一种思想，启发大家的思维。框架，自动化代码生成和测试驱动的架构是核心内容，其中框架又是贯穿始终的要素。有人问我，什么是架构师，怎么样才能成为架构师？我回答说：编码，编码，再编码；改错，改错，再改错。当你觉得厌烦的时候，停下来想想，怎么才能更快更好的完成这些工作？架构师就是在实践中产生的，架构师来自于那些勤于思考，懒于重复的人。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/1243066710/"/>
      <url>/posts/1243066710/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>哈哈哈，这个界面测试用</p><p>这个第一个界面，按照程序员的惯例，“你好，世界”</p><p>“Hello，World！”</p><p><del>好了，这个界面就这样吧！总的来说还是很高兴的，纯小白，租了一个服务器，摸爬滚打的，历时4天，终于有一个像模像样的页面了。</del></p><p>在这个漫长的假期里（这要从一只蝙蝠说起…hahahaha），本着生命不息，折腾不止的原则，我又换了架构。同时我也这这个漫长的假期里换了工作，以后我就是一个正儿八经的的码农啦，可能以后的硬件部分更新的不会特别勤快，又或者是不更了，你们要原谅我哦。经历太有限啦，要做的事情太多啦。</p><p>现在这个博客已经脱离了我之前的那个服务器，之前的文章有一部分还是会搬过来的，做个搬运工好累 0.0</p><p>没准哪天想开了，用那个服务器做个酸酸乳，亦或者搭一个私服。。哈哈哈，都不一定呢，走一步看一步吧，换的新工作而且还换行了，前两年的算是白干了，希望以后不会荒废这点技能，毕竟技多不压身，哈哈哈，好贪心啊我。新的工作好多事情要去学习，要去磨合，一起加油！！！A za a za~</p><p>现在终于可以踏踏实实的记录一些点滴了。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件研发成本,除了元器件还有什么?</title>
      <link href="/posts/51501505/"/>
      <url>/posts/51501505/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>很多初创团队计算一个项目是否启动的时候，一般都会先评估BOM成本，然后评判项目是否能够承接。一些客户，也会在面对硬件团队的报价，会表示不理解，为什么比淘宝价贵这么多？</p><p>今天就来细数，除了BOM成本，硬件研发还有哪些成本。</p><h2 id="第一，人力成本。"><a href="#第一，人力成本。" class="headerlink" title="第一，人力成本。"></a>第一，人力成本。</h2><p>人是最宝贵的，也是最贵的。在硬件产品的全流程中的人力投入粗略评估。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/640.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/640.png" class="lazyload" title></a></p><p>在整个研发流程中，各个环节所需要的人力投入都是需要进行评估的。如果对某一个环节在前期投入不足，一定会造成后续环节的时间加大投入。而且早期不解决问题，越到后期想解决，所带来的代价就会越大。</p><p>例如，如果在早期在器件选型的时候，对于器件生命周期的评估不准确，或者缺少评估。当产品量产后，发现关键器件已经部分或者全部厂家已经停产，则需要备货或者需要更改方案，带来的人力成本是非常大的浪费。</p><p>在整个研发过程中，每个环节的人力投入，或者每个环节的人力成本预算都不可以省略，或者进行裁剪需要进行严格的评估。</p><h2 id="第二、仪器仪表"><a href="#第二、仪器仪表" class="headerlink" title="第二、仪器仪表"></a>第二、仪器仪表</h2><p>万用表、示波器、稳压源这些常规的仪器仪表总要配备吧？你的电路涉及、射频、高速，所需要的仪器仪表的费用，那就不可估量了。</p><p>频谱分析仪、网络分析仪、信号发生器，配齐，发现一套二线城市的房子没有了。</p><p>曾经有一个人用6G带宽的示波器测试电源，被领导怒了：“你怎么拿着宝马测试电源。。。”</p><p>还有个人整天拿着一个极低噪声的频谱分析仪出差，也是胆战心惊，总说自己拎着房子在出差。</p><h2 id="第三、工具其实是消耗品"><a href="#第三、工具其实是消耗品" class="headerlink" title="第三、工具其实是消耗品"></a>第三、工具其实是消耗品</h2><p>除了仪器仪表，还有一些易耗品，工具：搞硬件嘛，螺丝刀，大的、小的、十字、一字，钳子：斜口钳、剥线钳、尖嘴钳；烙铁：烙铁头、烙铁芯、吸锡器、热风焊台，焊锡丝、吸锡扁带、助焊剂、松香、洗板水；镊子、弯头镊子、直头镊子；</p><p>5S做得不好，或者大家不爱惜的话，很容易工具丢失，或者损坏。而且有限工具是消耗品，例如镊子，·很容易变形，变得不能捏起0402封装的电容电阻。</p><h2 id="第四、改板"><a href="#第四、改板" class="headerlink" title="第四、改板"></a>第四、改板</h2><p>PCB制版，往往不是一次成功，可能会有一些错误、或者不稳定的因素，需要通过重新加工新版本的 PCB进行优化方案。如果在调测阶段的改板，主要浪费的是制版费、SMT、物料费用。如果在项目交付接近尾声的时候，如果这时候改板，则所有相关的环节都需要重新做一遍，试验、测试。造成的浪费和损失将会更大。</p><h2 id="第五、直通率"><a href="#第五、直通率" class="headerlink" title="第五、直通率"></a>第五、直通率</h2><p>直通率是对产品从第一道工序开始一次性合格到最后一道工序的参数，能够了解产品生产过程中在所有工序下产品直达到成品的能力，是反应企业质量控制能力的一个参数。</p><p>如果产品直通率不高，所带来的成本，有可能是产品报废率的成本，或者是维修的人力成本，都是极大的浪费。</p><p>直通率不但要关注SMT，还需要关注其他生产环节，结构件装配，生产测试等等。</p><h2 id="第六、物流费"><a href="#第六、物流费" class="headerlink" title="第六、物流费"></a>第六、物流费</h2><p>顺丰最贵，但是有时为了发货时间、稳定可靠，不得不选择。但是中通、德邦快递等等也是各自有各自的优势。</p><h2 id="第七、税费"><a href="#第七、税费" class="headerlink" title="第七、税费"></a>第七、税费</h2><p>之前，中小企业3%营业税。现在营改增。营业税改增值税（以下简称营改增）是指以前缴纳营业税的应税项目改成缴纳增值税，增值税只对产品或者服务的增值部分纳税，减少了重复纳税的环节，是党中央、国务院，根据经济社会发展新形势，从深化改革的总体部署出发做出的重要决策，目的是加快财税体制改革、进一步减轻企业税负，调动各方积极性，促进服务业尤其是科技等高端服务业的发展，促进产业和消费升级、培育新动能、深化供给侧结构性改革。</p><p>企业所得税的税率为25%的比例税率。</p><p>原“企业所得税暂行条例”规定，企业所得税税率是33%，另有两档优惠税率，全年应纳税所得额3－10万元的，税率为27%，应纳税所得额3万元以下的，税率为18%；特区和高新技术开发区的高新技术企业的税率为15%。外资企业所得税税率为30%，另有3%的地方所得税。新所得税法规定法定税率为25%，内资企业和外资企业一致，国家需要重点扶持的高新技术企业为15%，小型微利企业为20%，非居民企业为20%。</p><p>企业应纳所得税额=当期应纳税所得额*适用税率</p><p>应纳税所得额=收入总额-准予扣除项目金额</p><p>企业所得税的税率即据以计算企业所得税应纳税额的法定比率。根据《中华人民共和国企业所得税暂行条例》的规定，2008年新的<中华人民共和国所得税法>；规定一般企业所得税的税率为25%。</p><h2 id="第八、BOM清单中容易忽略的费用"><a href="#第八、BOM清单中容易忽略的费用" class="headerlink" title="第八、BOM清单中容易忽略的费用"></a>第八、BOM清单中容易忽略的费用</h2><p>除了元器件的采购，还有，结构件、开模费、线缆费用、连接器费用、包装、电源、外置天线，这些BOM清单里面的成本往往容易被忽略。</p><h2 id="第九、生产加工"><a href="#第九、生产加工" class="headerlink" title="第九、生产加工"></a>第九、生产加工</h2><p>PCB加工、SMT、整机装配、整机调测、包装。有一些产品在生产环节还需要特殊工艺：例如一些特殊环境的产品，需要做三防、打胶，有一些需要甚至需要做水密测试</p><h2 id="第十、维修、维护费用"><a href="#第十、维修、维护费用" class="headerlink" title="第十、维修、维护费用"></a>第十、维修、维护费用</h2><p>硬件产品售出之后，不是一卖了之。器件都有一点的失效率。器件、甚至包括一些结构件，不可能完全不损坏。现场的故障需要有人能解决，质保期的产品还需要维保。</p><h2 id="第十一、现场安装、升级"><a href="#第十一、现场安装、升级" class="headerlink" title="第十一、现场安装、升级"></a>第十一、现场安装、升级</h2><p>如果，远程搞不定的问题，可能还需要去现场安装、升级、调测。其中产生的差旅费，返修件、替换件等等，都需要成本支出。</p><h2 id="第十二、呆死料"><a href="#第十二、呆死料" class="headerlink" title="第十二、呆死料"></a>第十二、呆死料</h2><p>呆死、死料形成原因：1、设计改型后，原先的材料有新的替代料；2、采购过程中没有进行配套采购，多余的料就形成了呆死料；3、库房盘点不及时，对库存台账没有进行分析；4、材料没有保质期管理，长时间后，可用料变成无用料。</p><p>至此，我们也就可以清楚的看到硬件研发，除了物料成本之外，还有大量的成本需要支出。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式系统低功耗设计</title>
      <link href="/posts/3993218583/"/>
      <url>/posts/3993218583/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在嵌入式系统中，低功耗设计是在产品规划以及设计过程中必须要面对的问题。半导体芯片每18个月性能就能翻一倍，但同时，电池的技术却跟不上半导体的步伐，同体积的电池10年容量才能翻一倍，嵌入式系统对于使用时间以及待机时间问题的要求越来越高了。这就需要在设计过程充分考虑功耗的问题，可以从以下几个角度来分别考虑，然后统筹规划。</p><h2 id="1、低功耗器件选型"><a href="#1、低功耗器件选型" class="headerlink" title="1、低功耗器件选型"></a>1、低功耗器件选型</h2><p>随着半导体工艺的不断发展，半导体的制造工艺也在不断进步，选用先进工艺以及低功耗设计的元器件可以从源头上降低整个系统的功耗。</p><p>1）主控芯片的选型要充分考虑到系统的使用场景，对于运算任务比较多的应用场景下，可选用能耗比较高的芯片来设计，比如ambiq的apollo系列芯片，该芯片采用具有专利的spot技术，芯片在亚阈值稳定运行，可以减小能源消耗近14倍，实现极致的低功耗。</p><p>2）对于嵌入式系统，电源芯片对于低功耗设计是一个很重要的器件，电源芯片自身的功耗以及转换效率在很大程度上影响电池的使用时间，进行低功耗的稳压电路设计，需采用低功耗的LDO或DC-DC芯片，如Ti的TPS797系列，自身功耗仅1.2uA。</p><p>3）在满足功能需求的情况下，尽可能选用带触发输出功能的外部器件，及时关闭非需要轮询的外部器件，这样可以减小整体的功耗，同时也可以减少MCU的运行时间，平时Mcu可以一直处于睡眠状态，在满足出发条件时，由外部器件通过中断来唤醒MCU工作。</p><h2 id="2、硬件的低功耗设计与制造技术"><a href="#2、硬件的低功耗设计与制造技术" class="headerlink" title="2、硬件的低功耗设计与制造技术"></a>2、硬件的低功耗设计与制造技术</h2><p>硬件设计对于嵌入式系统的功耗也有着至关重要的因素。</p><p>1）对外围元器件的电源控制，采用带关断功能的器件，对于那些在进入低功耗模式下不需要工作的外设，可以使用MOS管电路并配合Mcu控制或者片选/使能引脚对局部的电路进行电源管理，在该设备不需要工作时，需尽量关断该部分电源以达到更低的功耗。</p><p>2）多级电压设计，电压与功耗之间有着密切的联系，因此功耗的降低可以考虑对于不同电路模块，使用不同的电压模块等级，采用DVFS动态电压频率技术，通过将不同电路模块的工作电压及工作频率降低到恰好满足系统最低要求，来实时降低系统中不同电路模块功耗的办法。</p><p>3）硬件设计对于MCU的每个IO口，都要避免IO口漏电流。当外设掉电时，IO口仍然会有潜在的电流输出，所以IO口需要默认配置成低电平或者高电平状态，避免漏电流。</p><h2 id="3、软件对于系统功耗的优化"><a href="#3、软件对于系统功耗的优化" class="headerlink" title="3、软件对于系统功耗的优化"></a>3、软件对于系统功耗的优化</h2><p>1）适当的降低CPU的运行频率，降低MCU的运行速度，可以有效的降低运行时需要消耗的电流，芯片的功耗和主频是线性的关系，更高的时钟频率意味着更快的MCU运行速度，那么MCU内部CMOS电路更快的开关频率，导致更高的运行电流和待机电流。</p><p>2）合理的使用MCU的待机模式，在当前没有任务需要处理时，将MCU进入低功耗的睡眠模式。对于使用嵌入式操作系统的嵌入式产品，一般都是在idle空闲任务中进入睡眠模式，但是为了进一步降低功耗，实现低功耗最优设计，我们还不能直接把谁爱你或者停机模式直接放在空闲任务就可以了，需要设计一种更先进的休眠机制，比如在freertos操作系统中使用tickless低功耗机制，进入空闲任务后，首先计算可以执行低功耗的最大时间，也就是求出下一个要执行的高优先级任务还剩多长时间，然后把低功耗的唤醒时间设置为这个求出的时间，到时间后，系统会从低功耗模式被唤醒，继续执行多任务。</p><p>3）关注每一个GPIO口的电平状态，在进入睡眠之前，配置所有的GPIO口到高电平或者低电平以降低漏电流。对于外挂的传感器以及外围设备，也需要在进入睡眠之前配置其功耗模式以降低消耗的电流。</p><p>4）合理的关闭MCU内部模块，对于在DeepSLeep模式下不需要工作的内部模块都要关闭时钟以及电源以节省功耗，同时要重点关注模拟IO口，模拟功能一般是耗电大户，在AD/DA功能不使用的时候尽快关闭，减小使用模拟功能的时间，此外，芯片内部SRAM由于要不停的刷新，在睡眠模式下也需要消耗一定的电流，可以配置部分SRAM在睡眠模式下保持刷新降低功耗。</p><p>5）对于包含有无线功能的芯片，配置合理的待机参数以此降低功耗，比如对于BLE芯片CSR1010，在进行BLE广播模式下，60ms的广播时间增大到1.28s，待机电流降低到28uA。对于wifi芯片，比如高通QCA4004芯片，在DTIM1情况下对应功耗为1.5mA，在DTIM10 情况下则降低到334uA 。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 低功耗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 低功耗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开关电源基础知识</title>
      <link href="/posts/2454698225/"/>
      <url>/posts/2454698225/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="1、输出纹波噪声及输出电路的处理"><a href="#1、输出纹波噪声及输出电路的处理" class="headerlink" title="1、输出纹波噪声及输出电路的处理"></a>1、输出纹波噪声及输出电路的处理</h2><p>PWM开关电源的输出纹波噪声与开关的频率有关。其纹波噪声分为两大部分：纹波（包括开关频率的稳波和周期性及随机性漂移）和噪声（开关过程中产生）</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power1.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power1.png" class="lazyload" title></a></p><p>在纹波与噪声的测量过程中，如果不使用正确的测量方法将无法正确的测量出真正的输出纹波噪声。下面是推荐的测量方法：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power2.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power2.png" class="lazyload" title></a></p><p>平行线测量法：输出管脚接平行线后接电容，在电容两端使用20MHz示波器探头测量。具体要求见上图，C为陶瓷电容，负载与模块之间的距离在51mm和76mm（2in和3in）之间。<br>在大多数电路中，电源模块都能满足要求，对于输出纹波有较为严格要求的电源系统可以在输出增加差模滤波器来进一步降低纹波，但在设计过程中注意尽量选择较小的电感和较大的电容，如果需要进一步减小噪声，需要加共模滤波器。</p><p>输入与输出及外壳之间加高压隔离电容（一般为1~2.2nF）也可以减小共模噪声。</p><h2 id="2、多路输出的交互调节及应用"><a href="#2、多路输出的交互调节及应用" class="headerlink" title="2、多路输出的交互调节及应用"></a>2、多路输出的交互调节及应用</h2><p>对于多路输出的电源模块，人们比较关心输出负载发生变化时不同输出路的相互见的影响。例如，当主路输出空载时，辅路输出的负载能力极低。 可以采用集成磁路的概念或者采取双路同步控制使输出电压之间的交互调节性大大改善。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power3.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power3.png" class="lazyload" title></a></p><p>图中的Io1为主路的负载电流，Io2为辅路的负载电流，Vo2为辅路的输出电压<br>由上图可见，在主路负载从20%~100%变化时，辅路输出电压随辅路负载电流得到变化曲线中，辅路输出电压始终在±4%范围内。即使在最坏的情况，即主路空载辅路满载、主路满载辅路空载时，其输出电压也能保证在标称电压的±10%范围内。由此，对于输出稳压精度要求不太高的情况下，这种不稳压的辅路输出不仅能够满足供电的需求，而且相对成本低，器件少，可靠性高。建议用户首先考虑不稳压的电源模块。</p><h2 id="3、容性负载能力与电源输出保护"><a href="#3、容性负载能力与电源输出保护" class="headerlink" title="3、容性负载能力与电源输出保护"></a>3、容性负载能力与电源输出保护</h2><p>建议用户对电源模块的阻性负载取大于10%额定负载，这样模块工作比较稳定。</p><p>电容作为电源去耦及抗干扰能力的手段，在现代电子电路中必不可少，尤其是输出过载保护，容性负载能力不可能太大，否则保护特性将变差因此用户在使用过程中负载电容不应超过最大容性负载能力。</p><p>输出电流保护一般有五种方式：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power4.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power4.png" class="lazyload" title></a></p><p>1）恒流式：当到达电流保护点时，输出电流随负载的进一步加重，略有增加，输出电压不断下降。<br>2）回折式：当到达电流保护点时，输出电流随负载的加重，输出电压不断下降，同时输出电流也不断下降<br>3）截止式：当达到电流保护点时，电源模块输出被禁止。<br>4）恒流-截止式：当到达电流保护点时，首先是恒流式的保护方式，当输出电流达到某值时，电源模块输出被禁止。<br>5）精确自恢复截止式：输出电流达到保护点，电源模块输出被禁止，负载减轻电路自恢复。</p><p>在大部分电路中使用恒流式和截止式较多，比较理想的保护方式是精确自恢复截止式或者恒流-截止式保护。其中恒流式、回折式保护的本质就是自恢复的，但是输出短路时的功耗较大，尤其是恒流式。而截止式、恒流-截止式保护的自恢复特性需加辅助复位电路来完成自恢复，其输出过载时的功耗可以通过复位电路的周期进行调整，即调整间歇启动时间间隔。一般电流保护1.2~2倍标称输出电流。精确自恢复截止式电流保护点设置为标称输出电流1.2倍或1.3倍。</p><p>一般输出有过压嵌位保护。</p><h2 id="4、负载瞬态响应"><a href="#4、负载瞬态响应" class="headerlink" title="4、负载瞬态响应"></a>4、负载瞬态响应</h2><p>当输出的负载迅速变化时输出的电压会出现上冲或下跌，电源模块经过调整恢复原输出电压。这个响应过程中有两个重要指标：过冲电压（Vo）和恢复时间（tr）。过冲越小、恢复时间越短，系统响应速度越快。一般在25%的标称负载阶跃变化，输出电压过冲为4%Vo，恢复时间为500us左右。</p><h2 id="5、热设计"><a href="#5、热设计" class="headerlink" title="5、热设计"></a>5、热设计</h2><p>由于电源模块的转换效率不可能是100%，因此自身有一定的功耗，电源模块本身发热的高低，主要取决于电源模块的转换效率，在一定我外壳散热条件下，电源模块存在一定的温升（即电源模块与环境温度的差异）。电源模块外壳散热表面积的大小直接影响温升。对于环境温度较高的地方，必须将模块降额使用以减小模块的功耗，从而减小温升，保证外壳温度不超过极限值。推荐用户根据环境条件降额使用模块电源，以获得较大的安全余量。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power5.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/power5.png" class="lazyload" title></a></p><p>对于功率较大的模块须加相应的散热器以使模块的温升下降，不同的散热器在自然散热的条件下有不同的对环境的热阻，主要影响散热器热阻的因素是散热器的表面积。</p><p>散热器的选择：假设电源模块的效率为η，最大基板允许温度为Tmax，则：电源的耗散功率为PD=Po*（1-η）/η；温差：ΔT=Tmax-Ta（Ta为环境温度）；则：散热器所需要的热阻Rth为：Rth=ΔT/PD；接下来我们只要查散热器的产品目录或手册，从中找出合适尺寸的、在合适环境及自然对流与辐射下的热阻值小于Rth的散热器即可。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何为嵌入式设计选择最优的8位MCU？</title>
      <link href="/posts/245078137/"/>
      <url>/posts/245078137/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>尽管竞争激烈，而且32bit的ARM cortex-M处理器等新平台的市场份额在强劲增长，现今8bitMCU仍占据着这个微控制器市场的很大一部分。其优势主要在于以下几个因素：低成本、简单、快速掌握用法以及成熟的生态系统，这个生态系统包含无处不在的工具库。</p><p>目前的8bit MCU技术已经十分成熟，其价格已经接近其下限，这为开发人员带来了选择难题，在选型的时候有很多具有相似价格和功能的产品但是哪个才是最优的选择呢？</p><h2 id="1、生态系统"><a href="#1、生态系统" class="headerlink" title="1、生态系统"></a>1、生态系统</h2><p>1）工具</p><p>当成本成为嵌入式设计应该考虑的主要因素时，避免在编译器许可证或者编码环境花费资金是明智的。在选择MCU之前，请确认供应商的芯片和他们提供的软件示例是否能够在免费的开发平台上使用。否则取决于需要组件数量的不同，即使一家供应商的平均销售价格等于或高于另外一家，最终的实际花费成本也可能是较低的。</p><p>例如来自竞争厂商的两个基于8051的MCU选择可能具有类似的芯片价格，但工具成本不同。如果MCU供应商提供的基于8051的芯片缺少免费编译器或集成开发环境（IDE）许可证，则开发人员必须使用KEIL或IAR并支付许可费用，从而增加了项目的总投资。更加具有成本优势的选择是使用免费IDE和无限制KEIl许可证支持的8bit平台。</p><p>2）软件</p><p>一旦理解了编译器和开发环境，下一个隐形的技术指标是MCU平台上软件示例和生态系统的可用性。例如寻找那些为其外设提供大量代码示例的MCU供应商。这样可以轻松把控所需的每一个外设，如PWM、UART和ADC等等，然后将他们组合到一个项目中，就能很快地进入市场并增加潜在的收入，使得产品拥有更高的溢价能力，所以，良好的MCU生态系统可提供更高的性价比优势。</p><h2 id="2、技术指标：设计、特性和测试"><a href="#2、技术指标：设计、特性和测试" class="headerlink" title="2、技术指标：设计、特性和测试"></a>2、技术指标：设计、特性和测试</h2><p>在仔细阅读相对简单的8bit MCU规格书时，可以从数据手册的摘要中轻松的了解器件的功能，然后参考电气规格表以获得有关重要规格的更多详细信息。然而，事实上比看起来要更加复杂一点，开发人员应该考虑三个关键方面：（1)是否有对设计来说重要的最大值和最小值；（2）这些值的测试条件是否匹配实际使用情况；（3）这些参数是否得到设计、特性或者测试保证。</p><p>由于温度、VDD范围、工作频率和其他因素会影响设计中的真实值，因此需要始终谨慎考虑典型值。如今，业界常见的情况是：在一个基于另一个参数的技术指标下，会发生功能受限的情况。通常数据手册首页上会展现非常有吸引力的技术指标。然而，在深入研究电气技术规范表之后，很明显看似顶尖的技术参数仅存在于各个条件非常受限的情况下，这可能是实际应用环境所满足不了的情况，或者和设计的其他方面相冲突。这种错觉可能会导致失望、更严重的可能导致整个项目的前功尽弃，因为最初的最佳方案进来自首页，然后细读手册后发现那些特殊要求后，设计决策变得不那么明确了。</p><p>此外，在检查数据手册时，重要的是要研究注解，并了解它是否得到设计、特性或测试保证。通常设计在规格中有最低可信度，而测试在规格中有最大的信任度。</p><h2 id="3、灵活性和可扩展性"><a href="#3、灵活性和可扩展性" class="headerlink" title="3、灵活性和可扩展性"></a>3、灵活性和可扩展性</h2><p>在每个项目中切换不同架构和技术可能会推迟设计的完成，从而减缓产品上市时间，虽然供应商A的器件可能是手头项目的最佳选择，但供应商B可能有另外一款器件对于今年晚些时候的项目更好，这需要为每个项目进行优化、权衡并在之间重用开发成果。</p><p>所以在评估当前设计的供应商选择时，请确保他们拥有合适未来产品的解决方案仔细查看MCU系列中的每一个器件型号是值得的，这样能确保功能一致，并在移植到其他器件时不会牺牲重要的功能。</p><h2 id="4、寿命和供应保证"><a href="#4、寿命和供应保证" class="headerlink" title="4、寿命和供应保证"></a>4、寿命和供应保证</h2><p>8bit市场已经非常成熟，8bit器件也已经存在了几十年，因此，现在8bit器件的ASP非常低，这对开发人员来说很好，但对半导体供应商而言可能是个痛点，因为半导体供应商已经接近盈利最低点，而且一些供应商已经放弃 对其8bit产品的新品设计，当供应商发布其寿命终止（EOL）以及“不推荐用于新设计”（NRND）通知时，这种情况可能会变得令人担忧，这可能会威胁到最终产品的使用寿命。</p><p>MCU产品的使用寿命可能不是快速设计的关键问题，例如寿命短且快速下降的消费类产品，但对于医疗、汽车和工业应用来说至关重要，这些应用的终端产品常常需要两到三年的设计时间，然后其应用需求平缓的上升并持续超过10年，如果由于廉价8bit MCU停产而失去重要的、可盈利的终端产品市场，那么对于企业将是一个巨大的损失。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 选型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过远程桌面图形界面的方式操作Ubuntu服务器</title>
      <link href="/posts/3759941023/"/>
      <url>/posts/3759941023/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一段时间，在服务器上使用了IIS服务，虽然之前就有耳闻，IIS服务会有各种各样莫名其妙的坑，让你来慢慢填，并且网上相关的资料少的可怜，这次相信大家的选择了，这里也就不吐槽IIS了，既然选用了apache，那Windows留着也没啥意思 了，干脆直接换Linux，这次直接装了公共镜像Ubuntu18.04.1 LTS 64位，然后意识到没有图形界面，就倒腾倒腾。</p><h2 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h2><p>希望通过本地的Windows远程桌面，通过远程桌面图形界面的方式操作服务器。</p><h2 id="具体实现方式："><a href="#具体实现方式：" class="headerlink" title="具体实现方式："></a>具体实现方式：</h2><p>(1) 首先通过Windows系统下连接Linux系统的命令行工具连接Ubuntu服务器,(工具:xshell,securecrt,putty等)。</p><p>(2) 通过Windows下工具连接到linux操作系统,之后打开命令窗口,切换到root权限。</p><p>(3) 先安装更新:apt-get upate。</p><p>(4) 安装xrdp:输入apt-get install xrdp–>回车–>输入”y”–>回车,安装完成。<br>(xrdp: An open source remote desktop protocol(rdp) server)</p><p>(5) 安装vnc4server:输入apt-get install vnc4server”–>回车–>输入”y”–>回车,安装完成。<br>(VNC (Virtual Network Console)是虚拟网络控制台的缩写)</p><p>(6) 安装xfce4:输入apt-get install xubuntu-desktop”–>回车–>输入”y”–>回车。<br>–>输入echo “xfce4-session” >~/.xsession–>回车–>输入 service xrdp restart–>回车,安装完成。<br>(Xfce是一个自由软件,运行在类Unix操作系统 (如Linux、FreeBSD 和 Solaris)上,提供轻量级桌面环境。)</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/Ubuntu1.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/Ubuntu1.png" class="lazyload" title></a></p><p>(7) 在本地Windows电脑上,使用”窗口键+R”打开”运行对话框”–>输入”mstsc”–>回车–>输入Ubuntu主机的IP地址–>”连接”。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/Ubuntu2.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/Ubuntu2.png" class="lazyload" title></a></p><p>(8) 选择”sesman-Xvnc”–>输入”用户名和密码”–>回车,成功登录到Ubuntu桌面,现在可以进行远程操作了。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/Ubuntu3.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/Ubuntu3.png" class="lazyload" title></a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>界面是看到了，但是对于服务器的资源消耗比较严重，所以就不要这个功能了，还是老老实实的用命令行吧。>_<</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UCCx8C4x BiCMOS低功耗电流模式PWM控制器（ucc28c40）</title>
      <link href="/posts/1574715952/"/>
      <url>/posts/1574715952/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一段时间（很长很长的一段时间）安排了一些电源设计的工作，发现了一个PWM控制器，略有感触，记录一下。ti的片子，手册如下：<a href="http://www.ti.com/cn/lit/ds/symlink/ucc28c40.pdf" target="_blank" rel="noopener">http://www.ti.com/cn/lit/ds/symlink/ucc28c40.pdf</a></p><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p>UCCx8C4x系列是高性能，电流模式PWM控制器。UCCx8C4x是增强型BiCMOS版本，与业界标准UCx84xA系列和UCx84x系列PWM控制器具有引脚对引脚兼容性。BiCMOS技术提供更低的功耗，以提高效率以及更快的电流检测和振荡器频率。此外，7 V的较低启动电压版本作为UCCx8C40和UCCx8C41提供，用于电池系统。UCC28C4x系列的额定工作温度范围为-40°C至105°C，UCC38C4x系列的工作温度范围为0°C至70°C。</p><p>该系列提供控制固定频率，峰值电流模式电源的必要功能，具有以下性能优势。该器件提供高达1 MHz的高频工作，适用于高速应用。与UCx84x系列相比，经过调整的放电电流可以更精确地编程最大占空比和死区时间限制。降低启动和工作电流可最大限度地降低启动损耗和低工作功耗，从而提高效率。该器件还具有35 ns的快速电流检测输出延迟时间，可在电源开关上实现出色的过载保护，并具有±1 A的峰值输出电流能力，并可改善直接驱动大型外部MOSFET的上升和下降时间。</p><h2 id="功能框图"><a href="#功能框图" class="headerlink" title="功能框图"></a>功能框图</h2><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/blockdia_slus458.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/blockdia_slus458.gif" class="lazyload" title></a></p><h2 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h2><h3 id="1、-COMP"><a href="#1、-COMP" class="headerlink" title="1、 COMP"></a>1、 COMP</h3><p>UCCx8C4x系列中的误差放大器具有1.5 MHz的单位增益带宽。COMP端子可以提供电流和吸收电流。误差放大器在内部是电流限制的，因此可以通过外部强制COMP到GND来命令零占空比。</p><h3 id="2-、FB"><a href="#2-、FB" class="headerlink" title="2 、FB"></a>2 、FB</h3><p>FB是误差放大器的反相输入。误差放大器的同相输入内部调整为2.5 V±1％。FB用于控制电源转换器电压反馈环路的稳定性。为获得最佳稳定性，请尽可能缩短FB引线长度，尽可能缩小FB杂散电容。</p><h3 id="3-、CS"><a href="#3-、CS" class="headerlink" title="3 、CS"></a>3 、CS</h3><p>UCCx8C4x电流检测输入直接连接到PWM比较器。将CS连接到MOSFET源极电流检测电阻。PWM使用该信号终止OUT开关导通。可以对该引脚施加电压斜坡，以使用电压模式控制配置运行器件或增加斜率补偿。为防止由于前沿噪声引起的误触发，可能需要RC电流检测滤波器。电流检测放大器的增益通常为3 V / V.</p><h3 id="4-、RT-CT"><a href="#4-、RT-CT" class="headerlink" title="4 、RT / CT"></a>4 、RT / CT</h3><p>RT / CT是振荡器定时引脚。对于固定频率操作，通过在VREF和RT / CT之间连接一个电阻来设置定时电容充电电流。通过将定时电容从RT / CT连接到GND来设置频率。为获得最佳性能，请将定时电容引线尽可能短且直接接地。如果可能，请为定时电容和所有其他功能使用单独的接地走线。</p><p>UCCx8C4x的振荡器允许工作在1 MHz。该器件使用外部电阻设置外部电容的充电电流，从而决定振荡器频率。TI建议定时电阻值为1kΩ至100kΩ，定时电容值为220 pF至4.7 nF。UCCx8C4x振荡器适用于较低频率的原始双极器件的曲线，但将频率可编程范围扩展至至少1 MHz。这使器件能够在需要时提供引脚对引脚功能，并能够将工作范围扩展到更高的频率。有关设置振荡器频率的元件值，请参见下图。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/D001_slus458-300x224.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/D001_slus458-300x224.gif" class="lazyload" title></a></p><h3 id="5-、GND"><a href="#5-、GND" class="headerlink" title="5 、GND"></a>5 、GND</h3><p>GND是信号和电源返回地。TI建议将信号返回路径和高电流栅极驱动器路径分开，以使信号不受开关电流的影响。</p><h3 id="6-、OUT"><a href="#6-、OUT" class="headerlink" title="6 、OUT"></a>6 、OUT</h3><p>UCCx8C4x的高电流输出级为了直接驱动功率MOSFET而经过重新设计，图腾柱输出驱动器吸收或提供高达1 A的电流峰值。UCCx8C40，UCCx8C42和UCCx8C43器件的OUT以与振荡器相同的频率切换，并且可以在100％占空比附近工作。在UCCx8C41，UCCx8C44和UCCx8C45中，由于内部T触发器，OUT的开关频率是振荡器的一半。这将UCCx8C41，UCCx8C44和UCCx8C45的最大占空比限制为<50％。</p><h3 id="7-、VDD"><a href="#7-、VDD" class="headerlink" title="7 、VDD"></a>7 、VDD</h3><p>VDD是该器件的电源输入连接。在正常工作时，通过限流电阻为VDD供电。绝对最大电源电压为20 V（瞬间超过之后也会烧毁芯片，之前没太注意让vdd为12v觉得离20v还有8v的安全电压，也没有加入限流电阻，震荡之后，会把vdd直接带飞，坏了不少片子，当时买的单价大概17元左右把很是心疼，所以这里要慎重），包括可能存在的任何瞬变。如果超过此电压，可能会损坏设备。这与之前的双极型器件形成对比，后者可在输入偏置引脚上承受高达30 V的电压。此外，由于器件中不包含内部钳位，因此必须保护VDD引脚免受可能超过20 V电平的外部源的影响。如果包含来自辅助绕组N A的启动和自举电源电压在所有线路和负载条件下都不能达到20 V以下，使用从VDD到GND的齐纳保护二极管。根据自举电源的阻抗和布置，可能需要在辅助绕组上串联一个电阻R_VDD，以限制流入齐纳二极管的电流。确保在所有公差和温度范围内，最小齐纳电压高于最高UVLO上限阈值。为确保不产生与噪声相关的问题，请使用陶瓷旁路电容将VDD滤波至GND。VDD引脚必须尽可能靠近GND引脚去耦。</p><h3 id="8-、VREF"><a href="#8-、VREF" class="headerlink" title="8 、VREF"></a>8 、VREF</h3><p>VREF是误差放大器以及IC中许多其他内部电路的参考电压。UCCx8C4x系列的5V参考容差为±1％。高速开关逻辑使用VREF作为逻辑电源。参考电压在内部分压为2.5 V±1％，并连接到误差放大器的同相输入，以实现精确的输出电压调节。参考电压设置内部偏置电流和阈值，用于振荡器上限和下限阈值以及过流限制阈值。输出短路电流为55 mA（最大值）。为避免设备过热和损坏，请勿将VREF拉至接地，以此作为终止开关的方法。为了提高参考稳定性并防止高速开关瞬态噪声问题，使用靠近IC封装的陶瓷电容将VREF旁路至GND。至少需要0.1μF陶瓷电容。参考上的外部负载需要额外的VREF旁路。除陶瓷电容器外，还可以使用电解电容器。</p><h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><h3 id="1、欠压锁定"><a href="#1、欠压锁定" class="headerlink" title="1、欠压锁定"></a>1、欠压锁定</h3><p>提供了三组UVLO阈值，分别具有（14.5 V和9 V），（8.4 V和7.6 V）和（7 V和6.6 V）的开启和关闭阈值。第一组主要用于离线和48V分布式电源应用，在这些应用中，较宽的磁滞允许较低的频率工作和较长的转换器软启动时间。第二组UVLO选项非常适合通常由12-VDC输入运行的高频DC-DC转换器。第三组是最新的，已添加到电池供电和便携式应用中。表2列出了各器件的最大占空比和UVLO阈值。</p><table><thead><tr><th>最大占空比</th><th>UVLO ON</th><th>UVLO Off</th><th>零件号</th></tr></thead><tbody><tr><td>100%</td><td>14.5伏</td><td>9伏</td><td>UCCx8C42</td></tr><tr><td>100%</td><td>8.4伏</td><td>7.6伏</td><td>UCCx8C43</td></tr><tr><td>100%</td><td>7伏</td><td>6.6伏</td><td>UCCx8C40</td></tr><tr><td>50%</td><td>14.5伏</td><td>9伏</td><td>UCCx8C44</td></tr><tr><td>50%</td><td>8.4伏</td><td>7.6伏</td><td>UCCx8C45</td></tr><tr><td>50%</td><td>7伏</td><td>6.6伏</td><td>UCCx8C41</td></tr></tbody></table><h3 id="2、电流检测和过流限制"><a href="#2、电流检测和过流限制" class="headerlink" title="2、电流检测和过流限制"></a>2、电流检测和过流限制</h3><p>外部串联电阻（R CS）用来检测电流并将该电流转换为电压，该电压成为CS引脚的输入，使用I SENSE=Vcs/Rcs来确定峰值I SENSE电流。CS引脚是PWM比较器的同相输入。将CS输入与差分放大器的同向输出电压的信号进行比较；电流检测放大器的增益通常为3 V / V。V CS的典型值为1V 。可能需要一个小的RC滤波器（R CSF和C CSF）来抑制由次级侧二极管的反向恢复或等效电容负载引起的开关瞬变，除了寄生电路阻抗。该滤波器的时间常数应大大小于转换器的开关周期。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/isense_circuit_slus458.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/isense_circuit_slus458.gif" class="lazyload" title></a><br>电流检测电路的原理</p><p>在PWM比较器上执行的逐周期脉宽调制的本质上是将差分放大器的输出与电流检测输入进行比较。这不是直接的电压比，因为差分放大器输出网络在连接到PWM比较器之前将两个二极管与一个电阻分压器网络串联在一起。两二极管压降会增加一个偏置电压，该偏置电压可实现低放大器输出的零占空比。2R / R电阻分压器有助于更宽泛的误差放大器输出摆幅的使用，该摆幅可以更对称地集中在2.5V同相输入电压上。</p><p>与差分放大器的PWM比较器输入相关的1V齐纳二极管不是该器件设计中的实际二极管，而是最大电流检测输入幅度为1 V（典型值）的指示。达到此阈值时，无论误差放大器的输出电压如何，都会出现逐周期电流限制，并且输出脉冲宽度在35 ns（典型值）内终止。该电流限制阈值的最小值为0.9 V，最大值为1.1V。除了此参数的公差之外，还必须考虑电流检测电阻或电流检测电路的精度。在确定所有功率半导体和磁性元件的额定值和最坏情况时，建议考虑一次和二次电流的最坏情况。</p><h3 id="3、振荡器同步"><a href="#3、振荡器同步" class="headerlink" title="3、振荡器同步"></a>3、振荡器同步</h3><p>通过将定时电容电压强制高于振荡器内部上限，可以最好地实现同步。一个小电阻与C CT串联到GND。该电阻器用作同步脉冲的输入，该同步脉冲将C CT电压升高到振荡器的内部上限阈值以上。允许PWM以R RT和C CT设置的频率运行，直到出现同步脉冲。该方案具有几个优点，包括使本地斜坡可用于斜率补偿。必须将UCCx8C4x振荡器的频率设置为低于同步脉冲流的频率，通常将其设置为20％，并在电阻两端施加0.5V脉冲。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/sync_circuit_slus458.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/sync_circuit_slus458.gif" class="lazyload" title></a><br>振荡器同步电路</p><h3 id="4、软启动"><a href="#4、软启动" class="headerlink" title="4、软启动"></a>4、软启动</h3><p>软启动是一种通过以零为起点缓慢增加有效占空比并逐渐上升的方式，以良好控制的方式逐渐为转换器供电的技术。PWM启动后，误差放大器的反相输入为低电平，命令误差放大器的输出变为高电平。放大器的输出级通常可提供1 mA的电流，足以驱动大多数高阻抗补偿网络，但不足以快速驱动大型负载。通过给一个较大的大于1 µF的电容充电（C SS），可以通过一个PNP晶体管连接到误差放大器的输出，从而实现软启动，如下图所示。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/ss_slus458.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/ss_slus458.gif" class="lazyload" title></a></p><p>放大器流入电容器的有限充电电流转化为差分放大器输出的dv / dt限制。当PWM比较器的输入之一逐渐升高时，这直接对应于电流模式控制系统中初级电流的某个最大变化率。R SS和C SS的值必须选择使COMP引脚以受控的速率上升，从而限制功率级提供的峰值电流。在软启动间隔完成之后，电容器继续充电至VREF，从而有效地将PNP晶体管从电路考虑中移除。在电流模式控制系统中，软启动执行的功能与电压模式控制中执行的功能不同，通常是首选功能。在电流模式下，软启动控制峰值开关电流的上升。在电压模式控制下，无论初级电流或上升速率如何，软启动都会逐渐扩大占空比。</p><p>电阻R SS和二极管的目的是，在正常运行期间，一旦软启动完成并且电容器已充满电，则将软启动电容器从误差放大器的路径中取出。每当PWM进入UVLO条件时，与电阻并联的可选二极管都会强制软启动，从而迫使VREF变低。如果没有二极管，则电容器会在短暂的电源中断或掉电期间保持充电状态，并且在重新施加VDD时不会启用软启动。</p><h3 id="5、启用和禁用"><a href="#5、启用和禁用" class="headerlink" title="5、启用和禁用"></a>5、启用和禁用</h3><p>有几种方法可以启用或禁用UCCx8C4x设备，具体取决于所需的重启类型。两种基本技术使用外部晶体管将误差放大器输出拉低（<2 V BE）或将电流检测输入拉高（> 1.1 V）。禁用信号的施加导致PWM比较器的输出为高。PWM锁存器以复位为主导，因此，在COMP或CS引脚的关断条件消除后，输出保持低电平直到下一个时钟周期为止。在没有软启动的情况下重启的另一种选择是将电流检测输入拉高到逐周期电流限制阈值以上。可以使用从基准电压到电流检测输入的逻辑电平P沟道FET。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/shutdown_ckt_slus458.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/shutdown_ckt_slus458.gif" class="lazyload" title></a></p><p>禁用电路</p><h3 id="6、坡度补偿"><a href="#6、坡度补偿" class="headerlink" title="6、坡度补偿"></a>6、坡度补偿</h3><p>使用电流模式控制时，需要使用斜率补偿来稳定占空比超过50％的整个环路。尽管不是必需的，但斜率补偿还可以在最大占空比低于50％的情况下提高应用的稳定性。通过将振荡器波形的一部分注入实际感测的初级电流来引入斜率补偿。这两个信号在滤波电容器的电流检测输入（CS）连接处相加。为了最大程度地减少振荡器上的负载，最好用一个小晶体管来缓冲定时电容器的波形，该小晶体管的集电极连接到参考电压。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/slope_compensation_slus458.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/slope_compensation_slus458.gif" class="lazyload" title></a></p><h3 id="7、电压模式"><a href="#7、电压模式" class="headerlink" title="7、电压模式"></a>7、电压模式</h3><p>在某些应用中，出于多种原因，电压模式控制可能是首选的控制策略。电压模式控制可通过任何电流模式控制器轻松执行，尤其是UCCx8C4x系列成员。要实现，需要生成一个0V至0.9V的锯齿形信号，以输入到电流检测引脚（CS），这也是PWM比较器的一个输入。将其与PWM比较器另一输入端的分频误差放大器输出电压进行比较。随着误差放大器输出的变化，它在不同的时间点与锯齿波形相交，从而产生不同的脉冲宽度。这是一种线性生成宽度与误差电压成比例的脉冲的简单方法。</p><p>通过使用一部分振荡器定时电容器（C CT）波形，可以实现电压模式控制。如下图所示：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/voltagemode_slus458.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/voltagemode_slus458.gif" class="lazyload" title></a></p><p>它可以被细分并馈送到电流检测引脚。必须选择振荡器的时序分量，使其尽可能接近线性锯齿波形。尽管定时电阻呈指数充电，但较大的定时电阻值和较小的定时电容值有助于近似更线性的波形。一个小晶体管用于缓冲电阻分压器网络负载中的振荡器定时分量。由于振荡器的较低时序阈值存在偏移，因此添加了一个隔直电容。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><p>UCCx8C4x控制器是峰值电流模式脉冲宽度调制器。这些控制器具有一个板载放大器，可用于隔离和非隔离电源设计中。板上有一个图腾柱栅极驱动器，能够提供1 A的峰值电流。这是一种高速PWM，能够以高达1 MHz的开关频率工作。下图显示了典型的离线应用电路。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/typ_offline_app.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/typ_offline_app.gif" class="lazyload" title></a></p><h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><p>UCC28C42在离线反激式转换器中的典型应用下图所示。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/application_sch_new_slus458.gif" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/application_sch_new_slus458.gif" class="lazyload" title></a></p><p>UCC28C42使用内部电流控制环路，该环路包含一个小电流检测电阻器，用于检测初级电感器的电流斜坡。该电流检测电阻器将电感器电流波形转换为电压信号，该电压信号直接输入到初级侧PWM比较器中。该内部环路确定对输入电压变化的响应。外部电压控制环路涉及将输出电压的一部分与误差放大器输入端的参考电压进行比较。在离线隔离应用中使用时，隔离输出的电压反馈可使用次级侧误差放大器和可调电压基准（例如TL431）来实现。误差信号使用光隔离器跨越一次隔离到二次隔离边界，其光收集器连接到VREF引脚，发射极连接到FB。外部电压控制环路确定对负载变化的响应。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电源设计的优先级</title>
      <link href="/posts/2420910988/"/>
      <url>/posts/2420910988/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>排在优先级第一位的是电源的设计方向。对于磁芯而言，大的设计方向有4个，但是电源的设计方向会多一些，下面我列出了6个方向。</p><h2 id="设计方向一：极限尺寸"><a href="#设计方向一：极限尺寸" class="headerlink" title="设计方向一：极限尺寸"></a>设计方向一：极限尺寸</h2><p>例如Anker 30W PD充电器就做了一次极限小体积，把尺寸做到了最小，但是代价就是价格昂贵。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/20190607_104264_b60fb31d2ca3506fea290XVSwonReYfx-768x1289.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/20190607_104264_b60fb31d2ca3506fea290XVSwonReYfx-768x1289.jpg" class="lazyload" title></a></p><p>这里需要注意的是，极限体积下面还有一个小的设计方向——极限厚度，平板电视这类应用就是对电源的厚度有着非常严格的要求，所以有了平面变压器，PCB变压器这类的设计方案。</p><p>我们许多的电源应用都是限制尺寸设计方案，我们设计电源都会被各种要求尺寸尽可能小，能够适合一些特殊的外壳设计，这也是现代电源设计最常用的一个设计方案。</p><h2 id="设计方向二：极限低成本"><a href="#设计方向二：极限低成本" class="headerlink" title="设计方向二：极限低成本"></a>设计方向二：极限低成本</h2><p>说起这个，我们第一想到的就是大街小摊上随处可见的售价不足15元的山寨5V/1A的充电头。大家千万不要笑话，那个电路绝对是一个行业顶级工程师设计的，当然，之后抄作业的不算。虽然它什么安全标准都不符合，性能也一塌糊涂，但是它依然实现了基本功能，并且很赚钱，当然我不会建议大家学习这样的设计，毕竟这样的东西可能会毁掉一个行业。如何在符合安全标准的前提下尽可能的降低成本，这才是我们要学习的一个课题。</p><p>曾经我淘了一批（5、6个）这样的设计（电子垃圾）（有机会记录记录捡垃圾的事情），最后成交价格三块一个全新未拆封（当然还有可以一块钱可以拿下的东西，那个在用料上就已经看出低劣的特性了），拆解了一个，仔细看过电路（也没啥好看的），你会惊叹这个设计，当然我还是大胆的把它接上电，长时间给我的音响供电，基本功能还是可以的，如果没有保护措施，不建议使用该类产品，更不建议使用该类产品给贵重设备供电，比如手机之类的。毕竟马有失蹄的时候，这类产品出现问题的可能性要远远超过正规产品。</p><h2 id="设计方向三：极限高低温"><a href="#设计方向三：极限高低温" class="headerlink" title="设计方向三：极限高低温"></a>设计方向三：极限高低温</h2><p>许多应用需要相对较宽的环境温度容忍度，于是就有了宽温磁芯和宽温电容的市场。但是很多时候，我们电源设计的时候都会忽略这条标准。例如丰田混合动力汽车普锐斯的电源系统，报价乍一看很贵，但是如果你仔细去核算一下宽温设计成本，就会发现报价其实是合理的。而且宽温设计对散热和电源转换效率都提出了很高的要求，这些要求最终就体现在体积和价格上。</p><h2 id="设计方向四：极限输入电压"><a href="#设计方向四：极限输入电压" class="headerlink" title="设计方向四：极限输入电压"></a>设计方向四：极限输入电压</h2><p>由于电源的波动问题，许多应用环境是需要宽电压输入的，那宽电压设计的代价是什么呢？依然是体积和价格，而且宽电压设计会使变压器的利用率显著下降。许多人都会问，某某磁芯实际能做输出功率多大的电源？但是在不知道输入电压范围，不知道工作温度，也不知道客户能够承受的报价时，我们是没有办法说出某某磁芯能够对应的输出功率的。</p><h2 id="设计方向五：高可靠性"><a href="#设计方向五：高可靠性" class="headerlink" title="设计方向五：高可靠性"></a>设计方向五：高可靠性</h2><p>高可靠性其实是一个很模糊的定义。高可靠性究竟是什么？CQC认证？高EMC成绩？有人可能会说，电源用着不炸。那么什么才能保证你的电源不炸呢？没人敢给出明确的答案。</p><p>这里分享一个金升阳培训大会上的一个小故事，金升阳以前的电源推荐设计，使用的都是10k471压敏电阻。但不幸的是，总有个别地方会炸，数量并不多，一直查不出原因，最后改用了10k561型号的压敏电阻，问题彻底解决了。两者的区别只有压敏电阻不同，一个470v，一个560v，在正常的浪涌测试下，10卡71成绩更好，以为压敏电压低，可以吸收更多的浪涌，但是就是这款浪涌成绩更好的10k471最终成了设备故障的原因</p><p>因为压敏电阻其实是一次性器件，许多小的电压冲击虽然不能让压敏电阻彻底毁坏，但是会造成积累性的物理损伤，最终导致压敏电阻炸毁，虽然压敏电阻称职的完成了自己的使命，但是顾客不满意了，因为电源炸了，要修了。所以最后大家都换上了10k561压敏电阻。</p><p>高可靠性是评价一位工程师是否有经验的地方，是看不见的价值，也是最容易被忽略的地方，那技术指标是不是不重要了呢？当然不是，技术指标依然是必须要追求的硬指标。</p><h2 id="设计方向六：高可生产性"><a href="#设计方向六：高可生产性" class="headerlink" title="设计方向六：高可生产性"></a>设计方向六：高可生产性</h2><p>可生产性可能是许多人忽视的内容，行业内有专业设计电源经验的工程师非常紧俏，多数人设计电源是新手上路（我当然也是这个行列里面的），把电源当作数字电路板设计，这肯定是要吃苦头的。其实不管设计什么电路，我们首先要知道自己工厂的加工工艺如何，这就是所谓的可生产性和可制造性。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开关电源——输入瞬态电压保护</title>
      <link href="/posts/1708959747/"/>
      <url>/posts/1708959747/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h2><p>尽管各种开关变换技术在电路设计上存在很大的不同，但是经过多年的发展，都具备相似的基本功能特性，成为普遍接受的工业标准，不论设计方案和电路如何，设计者在确定设计之前必须考虑的标准的所有细节， 否则在设计和开发结束时再去增加一些细微的、曾被忽略的功能往往是非常困难的。</p><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><p>离线（direct-off-line)开关电源 ：“离线”（direct-off-line)开关电源之所以得其名，是因为它直接由交流电源供电，而不采用线性电源常用的、体积庞大的50~60Hz低频隔离变压器。</p><h2 id="交流电力线的浪涌保护"><a href="#交流电力线的浪涌保护" class="headerlink" title="交流电力线的浪涌保护"></a>交流电力线的浪涌保护</h2><p>随着“离线”开关电源中灵敏电子基本控制电路的使用，人们已更普遍地认识到交流供电输入电线的瞬变浪涌保护和必要性。</p><p>IEEE多年的测量结果展示了统计基础上各种人为或自然的电气现象发生的频率、典型辐维和波形数据。这些发现发表在IEEE 587-1980标准，见表1.2.1.这些工作为交流输入电线的瞬变浪涌保护设备的设计提供基础。<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/KcP4pNoRwGV5Aml.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/KcP4pNoRwGV5Aml.jpg" class="lazyload" title></a></p><p>1、在高阻抗的测试样品或负载电路中，电压表现为浪涌电压。在仿真测试中，采用测试发生器的开路电压值。<br>2、在低阻抗的测试样品或负载电路中，电流表现为浪涌的放电电流（而不是电力系统的短路电流），在仿真测试中，采用测试发生器的短路电流值。<br>3、有不同的钳位电压的其他抑制器会接收不同的能量水平。<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/j8u5Eezd9HWLr2a.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/j8u5Eezd9HWLr2a.png" class="lazyload" title></a></p><h2 id="（1）A类别："><a href="#（1）A类别：" class="headerlink" title="（1）A类别："></a>（1）A类别：</h2><p>输出端和长分支电路。这是最低应力的类别，适用于以下场合。<br>a.距 B类电力线超过10M（30ft)并采用14-10号线的所有引出线。<br>b.距电源输入超过20M(60ft)并采用14-10号线的所有引出 线。在这些远离接线端的位置，电压应力可达6KV，但电流应力相对低，最大只能达到200A。</p><h2 id="（2）B类别："><a href="#（2）B类别：" class="headerlink" title="（2）B类别："></a>（2）B类别：</h2><p>主馈电和短分支电路。这一类别包括 开关电源中所能见到的最高应力的场合。它应用于下面的场合。<br>a.配电屏装置<br>b.工厂中的总线和馈电系统<br>c.商用大楼的照明系统<br>注意：B类位置更接近于用户引入线。所受电压应力与A类别相似，但电流可达到300A。</p><h2 id="（3）C类别："><a href="#（3）C类别：" class="headerlink" title="（3）C类别："></a>（3）C类别：</h2><p>户外和用户引入线。这种位置在户外。非常高应力的情况都会发生，因为线距和绝缘间隔很大，并且闪络电压将会超过6KV，好在大多数开关电源都处于部分地受到保护的室内环境内的A或B类别位置，通常只需要保护A类和B类别应力的场合。</p><p>大多数室内配电屏和插座连接器在高于6KV或稍低于6KV电压时会引起火花，这些加上配电屏系统固有的电阻，使室内的应力状态限制在低得多的水平。<br>在 开关电源要进行浪涌保护的地方，应清楚地了解保护的类别，其归类应于预 期的位置一致。因为B类别位置保护装置比较大，价格比较高，所以除非明确地要求，否则不归类 到此保护 类别。<br>在全分布式开关电源系 统中要保护一些 开关电源，通常采用菜用一个总保护，可在全部系统的供电 输入线处安装一个瞬变浪流保护器。</p><h2 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h2><p>在低强度的A类场合，普遍地采用硅压敏电阻与瞬态抑制二极管、滤波电感和电容结合使。在更高功率地B类别场合，这些器件与更高额定电流地气体放电管或火花间隙配合使用，当使用气体放电装置时，也可以安装快速响应地熔断器或断路器。</p><h3 id="1、金属氧化物压敏电阻（MOV）："><a href="#1、金属氧化物压敏电阻（MOV）：" class="headerlink" title="1、金属氧化物压敏电阻（MOV）："></a>1、金属氧化物压敏电阻（MOV）：</h3><p>表现为电压依赖的电阻特性。在转变电压之下时，该器件具有高电阻和很小的负载。当两端电压超过转变电压时，其电阻急剧减小，而电流急剧增大。</p><p>优点：1）低成本。2）相当高的瞬变能量吸收能力。</p><p>缺点：在反复的过压下会逐渐老化并具有相当大的动态电阻。</p><h3 id="2、瞬态保护二极管（TVS-："><a href="#2、瞬态保护二极管（TVS-：" class="headerlink" title="2、瞬态保护二极管（TVS)："></a>2、瞬态保护二极管（TVS)：</h3><p>分为单向和双向两种。硅瞬态保护二极管由一个为高瞬变能力而配置地雪崩电压钳位器件构成。在双极型保护器中，采用两个结背对背地串联连接，而一个雪崩二极管在正向表现为一个普通二极管的特性。</p><p>优点：1）钳位动作非常快速，雪崩条件能在几个纳秒内建立。2）导通范围内的动态电阻非常低。</p><p>缺点：1）价格高（当热这个不是它的缺点，是我们的缺点😭）2）电流容量有限</p><h3 id="3、充气浪涌放电器："><a href="#3、充气浪涌放电器：" class="headerlink" title="3、充气浪涌放电器："></a>3、充气浪涌放电器：</h3><p>大得多的瞬变电流可由各种气体放电抑制器进行处理。在这类抑制器中，两个或更多的电极在密封的高压惰性气体环境里被精确地设置了间距，当电器两端电压超过起弧电压时，电极之间首先发生电离辉光放电，随着电流地增大，会产生电弧放电，这就为所有的内部电极之间提供了一条低阻抗的通道。</p><p>优点：1）有效短路电源，内部损耗较小。</p><p>缺点：1）对过压应力的反应速度相对慢。2）当瞬变过程结束时仍有维持导通的倾向。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/bpwNYSEcWyalsPG.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/bpwNYSEcWyalsPG.jpg" class="lazyload" title></a><br>具有噪声滤波器的交流电源火线—中线与交流电源线—地线的瞬变保护电路（使用了MOV、电涌放电器（SVP）和瞬变保护二极管（TVS）适用于中高功率的应用场合。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开关电源—MOS管GS震荡</title>
      <link href="/posts/2183954523/"/>
      <url>/posts/2183954523/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们测试MOS管GS波形时，有时会看到下图中的这种波形，在芯片输出端是非常好的方波输出，但一旦到了MOS管的G极就出问题了，有振荡，这个振荡小的时候还能勉强过关，但是有时候振荡特别大，看着都教人担心会不会重启。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/5PUKOe1mk8I3D9N.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/5PUKOe1mk8I3D9N.jpg" class="lazyload" title></a></p><p>IC出来的波形正常，到C1两端的波形就有振荡了。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>实际上这个振荡就是R1,L1和C1三个元器件的串联振荡引起的，R1为驱动电阻，是我们外加的，L1是PCB上走线的寄生电感，C1是mos管gs的寄生电容。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/WAQdECZ1T8MpeIs.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/WAQdECZ1T8MpeIs.jpg" class="lazyload" title></a></p><p>对于一个RLC串联谐振电路，其中L1和C1不消耗功率，电阻R1起到阻值振荡的作用阻尼作用。上图可以简化为：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/t9Dc3pjnJ2CPdZG.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/t9Dc3pjnJ2CPdZG.png" class="lazyload" title></a></p><hr><h2 id="建立方程求解"><a href="#建立方程求解" class="headerlink" title="建立方程求解"></a>建立方程求解</h2><p>RLC串联电路的微分方程，先列KVL</p><p>uR(t)+uL(t)+uC(t)=uS(t)</p><p>带入元件VCR</p><p>i(t)=iL(t)=iC(t)=c*duC/dt</p><p>uR(t)=Ri(t)=RC*duC/dt</p><p>uL(t)=L<em>di/dt=LC</em>d^2uC/dt^2</p><p>得：</p><p>LC<em>d^2uC/dt^2+RC</em>duC/dt+uC=uS(t)</p><hr><p>这是一个常系数非齐次线性二阶微分方程。为了得到电路的零输入响应，令uS(t)=0,得二阶齐次微分方程：</p><p>LC<em>d^2uC/dt^2+RC</em>duC/dt+uC=0</p><p>其特征方程为：LCs^2+RCs+1=0</p><p>解得：</p><p>s1=-R/(2L)+{[R/(2L)]^2-1/(LC)}^0.5</p><p>s2=-R/(2L)-{[R/(2L)]^2-1/(LC)}^0.5</p><p>特征根称为电路得固有频率。</p><hr><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>实际上这个电阻的值就决定了C1两端会不会振荡。</p><h3 id="1、当R1-gt-2-L1-C1-0-5时，S1，S2为不相等的实数根。过阻尼情况。"><a href="#1、当R1-gt-2-L1-C1-0-5时，S1，S2为不相等的实数根。过阻尼情况。" class="headerlink" title="1、当R1>2(L1/C1)^0.5时，S1，S2为不相等的实数根。过阻尼情况。"></a>1、当R1>2(L1/C1)^0.5时，S1，S2为不相等的实数根。过阻尼情况。</h3><p>齐次微分方程得解为：</p><p>uC(t)=A1<em>e^(s1</em>t)+A2<em>e^(s2</em>t)</p><p>A1、A2由初始条件确定:</p><p>令式中的t=0+得：uC（0+）=A1+A2</p><p>对uC(t)求导，再另t=0+得：[duC(t)/dt|t=0+]=A1<em>s1+A2</em>s2=iL(0+)/C</p><p>联立可求得：</p><p>A1=1/(s2-s1)*[s2*uC(0+)-iL(0+)/C]</p><p>A2=1/(s1-s2)*[s1*uC(0+)-iL(0+)/C]</p><p>将A1、A2带入uC(t)得到电容电压得零输入响应（mos得g极的电压），再利用KCL方程和电容的VCR可以得到电感电流的零输入响应。</p><p>当uC(0+)=U0,iL(0+)=0,t>0时：</p><p>uC(t)=s2<em>U0/(s2-s1)</em>e^(s1<em>t)-s1</em>U0/(s2-s1)<em>e^(s2</em>t)</p><p>i(t)=C<em>duC(t)/dt=U0/[L</em>(s2-s1)]*[e^(s1<em>t)-e^(s2</em>t)]</p><p>uL(t)=L<em>di/dt=U0/(s1-s2)</em>[s1<em>e^(s1</em>t)-s2<em>e^(s2</em>t)]</p><p>在这种情况下，基本不会发生振荡的。</p><h3 id="2、当R1-2-L1-C1-0-5时，S1，S2为两个相等的实数根。临界情况。"><a href="#2、当R1-2-L1-C1-0-5时，S1，S2为两个相等的实数根。临界情况。" class="headerlink" title="2、当R1=2(L1/C1)^0.5时，S1，S2为两个相等的实数根。临界情况。"></a>2、当R1=2(L1/C1)^0.5时，S1，S2为两个相等的实数根。临界情况。</h3><p>在这种情况下，有振荡也是比较微弱的。</p><h3 id="3、当R1-lt-2-L1-C1-0-5时，S1，S2为共轭复数根。欠阻尼情况。"><a href="#3、当R1-lt-2-L1-C1-0-5时，S1，S2为共轭复数根。欠阻尼情况。" class="headerlink" title="3、当R1<2(L1/C1)^0.5时，S1，S2为共轭复数根。欠阻尼情况。"></a>3、当R1<2(L1/C1)^0.5时，S1，S2为共轭复数根。欠阻尼情况。</h3><p>在这种情况下，电路一定会发生振荡。</p><hr><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以对于上述的几个振荡需要消除的话，我们有几个选择.</p><p>1，增大电阻R1使R1≥2(L1/C1)^0.5，来消除振荡，对于增大R1会降低电源效率的，我们一般选择接近临界的阻值。</p><p>2，减小PCB走线寄生电感，这个就是说在布局布线中一定要注意的。</p><p>3、增大C1,对于这个我们往往都不太好改变，C1的增大会使开通时间大大加长，我们一般都不去改变他。</p><p>所以最主要的还是在布局布线的时候，特别注意走线的长度“整个驱动回路的长度”越短越好，另外可以适当加大R1.</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开关电源主电路拓扑—Boost</title>
      <link href="/posts/3787596451/"/>
      <url>/posts/3787596451/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Boost变换器又称升压变换器、并联开关电路、三端开关型升压稳压器。</p><h2 id="线路组成"><a href="#线路组成" class="headerlink" title="线路组成"></a>线路组成</h2><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/4567.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/4567.png" class="lazyload" title></a></p><p>如图所示：电路由占空比为D的晶体管T，二极管D1，电感L和电容C组成的Boost变换器电路图。电路实现的功能为：把Vs升压到Vo。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>为了方便分析稳态特性、简化推导公式的过程，特作如下假定：</p><p>（1）开关晶体管、二极管均是理想元件、也就是可以快速地“导通”和“截止”，且导通时电压降为零，截止时漏电流为零。<br>（2）电感、电容是理想元件。电感工作在线性区而未饱和，寄生电阻为零，电容的等效串联电阻为零。<br>（3）输出电压中的纹波电压与输出电压的比值小到允许忽略</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/9876.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/9876.png" class="lazyload" title></a><br>Boost变换器电路的工作过程<br>当晶体管T导通时，电路如上图（a）所示，电流iL流过电感线圈L，电流线性增加电能以磁能的形式储存在电感线圈L中，此时，电容C放电，R上流过电流Io。R两端为输出电压Vo，极性上正下负。由于晶体管导通，二极管阳极接Vs负极，二极管承受反向电压，所以电容不能通过开关管放电。</p><p>当晶体管T关断时，电路如上图（b）所示，由于线圈L中的磁场将改变线圈L两端的电压极性，以保持 iL不变，这样线圈L磁能转化成电压VL与电源Vs串联，以高于Vo的电压向电容C、负载R供电。高于Vo时，电容有充电电流，等于Vo时，充电电流为零，当Vo有下降趋势时，电容向负载R放电，维持Vo不变。</p><p>由于VL+Vs向负载R供电时，Vo高于Vs，故称其为升压变换器。工作中输入电流is=iL是连续的。但是流经二极管D1电流是脉动的，由于有电容C的存在，负载R上仍有稳定、连续的负载电流Io。</p><h2 id="电路各点的波形"><a href="#电路各点的波形" class="headerlink" title="电路各点的波形"></a>电路各点的波形</h2><p>按iL在周期开始时是否从零开始，可以分为连续工作状态和不连续工作状态两种模式，波形分别如下图。</p><p>在iL连续工作状态，开关周期Ts最后的时刻电流Is值就是下一周期的开始值，但是如果电感量太小，电流线性下降快，即在电感中能量释放完时，尚未达到晶体管重新导通的时刻，因而能量得不到及时的补充，这样就会出现电流不连续的工作状态。再要求相同功率输出时，此晶体管和二级管的最大瞬时电流比连续状态下要大，同时输出直流电压的纹波也增加。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/1.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/1.png" class="lazyload" title></a><br>电感电流连续<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/4.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/4.png" class="lazyload" title></a><br>电感电流不连续<br>在连续状态下，输入电流不是脉动的，纹波电流随L增加而减小。不连续工作状态，输入电流iL是脉动的。晶体管输出电流iT不管连续或不连续工作方式总是脉动的。而且，峰值电流比较大。另外，在不连续时，D3*Ts的时间内，L从输出端脱离，这时只有电容C向负载提供所需的能量，因此，要求比较大的电容C，才能适应输出电压、电流纹波小的要求。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开关电源主电路拓扑—Buck</title>
      <link href="/posts/1840790501/"/>
      <url>/posts/1840790501/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Buck变换器又称为降压变换器，串联开关稳压电源、三端开关型降压稳压器。</p><h2 id="线路组成"><a href="#线路组成" class="headerlink" title="线路组成"></a>线路组成</h2><p>如图所示，由占空比为D的晶体管Tr，二极管D1，电感L和电容C组成的Buck变换器电路图。电路实现的功能为：把Vs转换成Vo。<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/SgzbCG53PZ89Etv.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/SgzbCG53PZ89Etv.png" class="lazyload" title></a></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>为了方便分析稳态特性、简化推导公式的过程，特作如下假定：</p><p>（1）开关晶体管、二极管均是理想元件、也就是可以快速地“导通”和“截止”，且导通时电压降为零，截止时漏电流为零。<br>（2）电感、电容是理想元件。电感工作在线性区而未饱和，寄生电阻为零，电容的等效串联电阻为零。<br>（3）输出电压中的纹波电压与输出电压的比值小到允许忽略。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>当晶体管Tr导通时，如图所示 流过电感线圈L 的电流：iL=is，负载R上流过的电流为Io，两端的电压为Vo，极性上正下负。当is>Io时，电容在充电状态。这时二极管D1承受反向电压。<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/YxcjAhs2fGCU3JM.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/YxcjAhs2fGCU3JM.png" class="lazyload" title></a></p><p>经过tON时间（tON为晶体管打开的时间）后，晶体管Tr截止，电路如下图，由于线圈L的电流不能突变，产生了反电动势，线圈两端的极性改变，负载R两端仍然是上正下负。在iL<io时，电容处在放电状态，以维持io、vo不变，这时二极管正向偏置，流经的电流为il（所以叫其续流二极管）。<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/WTUhre4FRYcxdjo.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/WTUhre4FRYcxdjo.png" class="lazyload" title></a></io时，电容处在放电状态，以维持io、vo不变，这时二极管正向偏置，流经的电流为il（所以叫其续流二极管）。<br></p><p>由于Vo<vs，故称其为降压变换器。工作电流在晶体管导通时is>0，在晶体管截止时is=0。但是输出电流Io在L、D、C的作用下是连续平稳的。</vs，故称其为降压变换器。工作电流在晶体管导通时is></p><h2 id="主要概念及关系式"><a href="#主要概念及关系式" class="headerlink" title="主要概念及关系式"></a>主要概念及关系式</h2><p>按照电感电流iL在周期开始时是否从零开始，可以分为电感电流连续工作模式和电感电流不连续工作模式两种，波形分别如下所示</p><h3 id="1、电感电流连续模式"><a href="#1、电感电流连续模式" class="headerlink" title="1、电感电流连续模式"></a>1、电感电流连续模式</h3><p>下面分析一下晶体管导通及截止与输出电压的关系。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ANPDCO2vZb5xcLu.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ANPDCO2vZb5xcLu.png" class="lazyload" title></a></p><p>设晶体管导通时间为tON=t1=D1<em>Ts，晶体管截止时间tOFF=t2-t1=D2</em>Ts（其中D1为导通占空比，D2为关断占空比，D1+D2=1，Ts为周期）<br>在输入输出不变的前提下，当晶体管导通时，波形如0~t1所示，电感电流平均值iL=Io=Vo/R。电感电流线性上升的增量为：<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/OCU3nPeXgcWDIhL.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/OCU3nPeXgcWDIhL.png" class="lazyload" title></a></p><p>当晶体管截止时，波形如t1~t2时间段所示，iL的电流增量为：<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ziHPIF1DqXloRbj.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ziHPIF1DqXloRbj.png" class="lazyload" title></a></p><p>由于稳态时这两个电流变化量相等，即 Δ iL1=| Δ iL2|，所以</p><p>(Vs-Vo)/L<em>D1<em>Ts=Vo/L</em>D2*Ts=Vo/L</em>(1-D1)*Ts</p><p>即Vo=Vs*D1</p><h3 id="2、电感电流不连续模式"><a href="#2、电感电流不连续模式" class="headerlink" title="2、电感电流不连续模式"></a>2、电感电流不连续模式</h3><p>当电感L较小，负载电阻较大，或Ts较大时，将出现电感电流已经降低到0，新的周期却没有开始，在新的周期内，电感电流从0开始线性增加，这种工作方式称为电感电流不连续的模式，波形如下图。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/1-1-1.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/1-1-1.png" class="lazyload" title></a><br>当晶体管导通时，占空比为D1 。 Δ iL1=（Vs-Vo）/L<em>D1</em>Ts<br>当晶体管截止时， Δ iL2=-Vo/ L<em>D2</em>Ts<br>由于 Δ iL1=| Δ iL2 |则：<br>（Vs-Vo）/L<em>D1</em>Ts=Vo/L<em>D2</em>Ts<br>即：Vo=D1/（D1+D2）*Vs<br>式中的D2为晶体管关断（二极管导通）时间占空比，这里D1+D2≠1</p><p>由波形图可以看出，稳态负载电流Io即是iL等腰三角形面积在Ts时间内的平均值，且Io=Vo/R。即：<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/D5kb9OctKV7i4wf.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/D5kb9OctKV7i4wf.png" class="lazyload" title></a></p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/Dbegr1LZUyVtqnN.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/Dbegr1LZUyVtqnN.png" class="lazyload" title></a></p><h3 id="3、连续与不连续的临界条件"><a href="#3、连续与不连续的临界条件" class="headerlink" title="3、连续与不连续的临界条件"></a>3、连续与不连续的临界条件</h3><p>在连续与不连续状态之间有个临界状态，由波形图所示：<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/DPHB7WE8nKgrCot.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/DPHB7WE8nKgrCot.png" class="lazyload" title></a><br>连续状态 Δ iL<2*Io</p><p>临界状态 Δ iL=2*Io</p><p>不连续状态 Δ iL >2*Io</p><p>整理得 Δ iL=Vo/L<em>D2</em>Ts=Vo/R<br>即：D2<em>Ts=2</em>L/R</p><p>临界电感L=D2<em>R</em>Ts/2=Vo<em>D2<em>Ts/2/Io=Vo</em>tOFF/2/Io=Vo^2</em>(1-D1)/2/Po/fs</p><p>其中fs为开关工作频率fs=1/Ts<br>Po为变换器输出功率Po=Io*Vo</p><h3 id="4、纹波电压-Δ-Vo"><a href="#4、纹波电压-Δ-Vo" class="headerlink" title="4、纹波电压 Δ Vo"></a>4、纹波电压 Δ Vo</h3><p>流经电容的电流ic（iL-Io）对电容充电产生的电压 Δ Vo称为纹波电压，其波形如图所示：</p><p>当ic为t的线性函数时<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/aCjX8xADMRQIB5W.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/aCjX8xADMRQIB5W.png" class="lazyload" title></a></p><p>由临界电感公式可知，对于L和D2为固定值时，降压变换器的电流连续与否是由R值决定的。当R增大时，工作状态将从连续转化为不连续。<br>另一方面，如果R和D2*Ts是固定的，则当电感器L<临界电感时，其工作状态由连续转化为不连续。<br>当fs增大时，即Ts减小，则保持开关变换器在连续状态工作的临界电感量降低。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电源设计的SOR</title>
      <link href="/posts/2582721021/"/>
      <url>/posts/2582721021/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="问题一：你希望设计的开关电源的工作电压范围是多少？85-256v还是195-265v？"><a href="#问题一：你希望设计的开关电源的工作电压范围是多少？85-256v还是195-265v？" class="headerlink" title="问题一：你希望设计的开关电源的工作电压范围是多少？85-256v还是195-265v？"></a>问题一：你希望设计的开关电源的工作电压范围是多少？85-256v还是195-265v？</h2><p>如果你愿意牺牲输入电压范围，那开关电源的整体体积就会缩小，成本也会降低。如果你需要85-256v的宽电压输入，那你的产品就可以销往110v电压供电的国家。<br>我的建议是国内销售的产品完全可以用单电压电源设计方案，例如在100-115v的国家使用85-35v的输入电压，而在国内产品用195-265v的输入电压，这样不仅可以降低成本、缩小体积，更可以避免水货对当地经销商的冲击。所以很多时候，通用的设计并不一定是最优的设计。</p><h2 id="问题二：你希望设计的开关电源有几路输出？"><a href="#问题二：你希望设计的开关电源有几路输出？" class="headerlink" title="问题二：你希望设计的开关电源有几路输出？"></a>问题二：你希望设计的开关电源有几路输出？</h2><p>简单的flyback多路输出只有一路输出是稳压的，如果用DC-DC产生多路输出则会增加成本。</p><h2 id="问题三：设计的多路输出之间是否需要隔离？"><a href="#问题三：设计的多路输出之间是否需要隔离？" class="headerlink" title="问题三：设计的多路输出之间是否需要隔离？"></a>问题三：设计的多路输出之间是否需要隔离？</h2><p>多路输出隔离会增加变压器屏蔽成本，而且不容易过辐射。</p><h2 id="问题四：每路输出的电压电流是多少？"><a href="#问题四：每路输出的电压电流是多少？" class="headerlink" title="问题四：每路输出的电压电流是多少？"></a>问题四：每路输出的电压电流是多少？</h2><p>开关电源产品的实际功率越大，产品的体积就越大，价格也会越高。</p><h2 id="问题五：电源的工作温度范围是多少？"><a href="#问题五：电源的工作温度范围是多少？" class="headerlink" title="问题五：电源的工作温度范围是多少？"></a>问题五：电源的工作温度范围是多少？</h2><p>常见的电源工作温度范围选项有-40-85℃、0-70℃,电源的工作温度范围越大，体积越大，价格越贵。</p><h2 id="问题六：高低压侧是否需要隔离？"><a href="#问题六：高低压侧是否需要隔离？" class="headerlink" title="问题六：高低压侧是否需要隔离？"></a>问题六：高低压侧是否需要隔离？</h2><p>有非隔离的AC-DC方案，而且价格也很便宜，不用定做变压器，用现成得到电感就可以。例如<br><a href="https://www.alldatasheet.com/view.jsp?Searchword=LNK302" target="_blank" rel="noopener" title="datasheet">lnk302芯片</a>其电路体积就比隔离电源小很多，而且设计快，占很多优势。</p><h2 id="问题七：高低压侧的隔离电压是多少？"><a href="#问题七：高低压侧的隔离电压是多少？" class="headerlink" title="问题七：高低压侧的隔离电压是多少？"></a>问题七：高低压侧的隔离电压是多少？</h2><p>隔离电压越高，变压器越贵，体积会越大，电源模块的总体积也越大，而且宽脚距的光耦也比普通的光耦要贵一些。</p><h2 id="问题八：对电源的尺寸有什么要求？"><a href="#问题八：对电源的尺寸有什么要求？" class="headerlink" title="问题八：对电源的尺寸有什么要求？"></a>问题八：对电源的尺寸有什么要求？</h2><p>电源的体积越小，价格越贵，容量越小。</p><h2 id="问题九：设计的制作工艺是什么？"><a href="#问题九：设计的制作工艺是什么？" class="headerlink" title="问题九：设计的制作工艺是什么？"></a>问题九：设计的制作工艺是什么？</h2><p>制作工艺有单面直插、正面直插正面贴片、正面直插反面贴片、一面直插两面贴片、两面直插两面贴片。<br>正面直插反面贴片最便宜，因为只需要一次波峰焊，但是需要点胶机。正面直插正面贴片次之，它需要一次回流焊，一次波峰焊。单面直插看似BOM成本最便宜，但由于人工成本居高不下，而且PCB的面积也相对最大，所以总体的设计比不划算。一面直插两面贴片是高密度设计，资金充裕时可以考虑使用，两面直插两面贴片是失败的设计，因为注定逃不掉手工焊接。<br>可能有人会问，就不能设计成全贴片的吗？回答是不能，因为大量的安规器件只允许用直插件，也只有直插件，所以AC-DC是逃不掉波峰焊的命运的。</p><h2 id="问题十：开关电源的限制功率输出温度是多少？"><a href="#问题十：开关电源的限制功率输出温度是多少？" class="headerlink" title="问题十：开关电源的限制功率输出温度是多少？"></a>问题十：开关电源的限制功率输出温度是多少？</h2><p>电源模块在极限高温和极限低温下都会有输出功率的缩水问题，一般情况下在-10~55℃会输出极限功率，超过60℃或者低于-10℃输出功率会直线下降。</p><h2 id="问题十一：开关电源的限制功率输出电压是多少？"><a href="#问题十一：开关电源的限制功率输出电压是多少？" class="headerlink" title="问题十一：开关电源的限制功率输出电压是多少？"></a>问题十一：开关电源的限制功率输出电压是多少？</h2><p>开关电源输入在极限高压和极限低压时也会有输出功率缩水的问题，一般有10%~20%的缩水。</p><h2 id="问题十二：开关电源需要通过哪些测试项目与等级？"><a href="#问题十二：开关电源需要通过哪些测试项目与等级？" class="headerlink" title="问题十二：开关电源需要通过哪些测试项目与等级？"></a>问题十二：开关电源需要通过哪些测试项目与等级？</h2><p>比如浪涌、辐射、传导、辐射抗扰度、传导抗扰度、EFT正态脉冲群、静电放电等等。需要通过的测试项目与等级级别越高，价格越贵。</p><p>EMC特性：<br><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/emctexing.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/post/emctexing.png" class="lazyload" title></a></p><h2 id="问题十三：电源的转换效率有什么要求？"><a href="#问题十三：电源的转换效率有什么要求？" class="headerlink" title="问题十三：电源的转换效率有什么要求？"></a>问题十三：电源的转换效率有什么要求？</h2><p>电源转换效率越高，芯片方案越新，当然价格也越高。</p><h2 id="问题十四：电源的稳波要求如何？"><a href="#问题十四：电源的稳波要求如何？" class="headerlink" title="问题十四：电源的稳波要求如何？"></a>问题十四：电源的稳波要求如何？</h2><p>稳波要求越高，输出的固态电容越多，体积越大，价格越高。</p><h2 id="问题十五：设计中是否接受塑料挡墙？"><a href="#问题十五：设计中是否接受塑料挡墙？" class="headerlink" title="问题十五：设计中是否接受塑料挡墙？"></a>问题十五：设计中是否接受塑料挡墙？</h2><p>许多电源为了安规距离无法达到的极限尺寸，会使用塑料挡墙来提高安规间距。</p><h2 id="问题十六：是否接受独立金属散热片？"><a href="#问题十六：是否接受独立金属散热片？" class="headerlink" title="问题十六：是否接受独立金属散热片？"></a>问题十六：是否接受独立金属散热片？</h2><p>增加散热片就意味着一堆工艺的加入，尤其是那种定尺寸外形的金属散热片，不仅需要机械工程师定做，还增加了人工安装的工时，所以许多40W左右的电源为了避免使用散热片，宁愿买一些贵一些的高效率芯片解决问题。</p><h2 id="问题十七：能接受的最终产品报价是多少？"><a href="#问题十七：能接受的最终产品报价是多少？" class="headerlink" title="问题十七：能接受的最终产品报价是多少？"></a>问题十七：能接受的最终产品报价是多少？</h2><p>这个问题可能让很多人心里没有底，但是我需要提醒大家，千万不要按照淘宝上卖的产品去估价。</p><h2 id="问题十八：能接受的产品加工工时是多久？"><a href="#问题十八：能接受的产品加工工时是多久？" class="headerlink" title="问题十八：能接受的产品加工工时是多久？"></a>问题十八：能接受的产品加工工时是多久？</h2><p>在需要爆量的时候，这是必须要考虑的问题。</p><h2 id="问题十九：研发时间多长？"><a href="#问题十九：研发时间多长？" class="headerlink" title="问题十九：研发时间多长？"></a>问题十九：研发时间多长？</h2><p>甲方要求的工期越短，单位时间工作量越大，工程价格就越贵，而且是以指数关系增长的。（这里吐槽一下，每一个电源的设计都是根据需求单独定制的，不同的设计之间虽有可以借鉴的地方，但是必要的研发工时是不可缺少的，同时研发的难度也是不降低的，并不是说之前做成功了一个电源，那么所有的电源设计就没有问题了，可以信手拈来，分分钟钟搞定）</p><h2 id="问题二十：研发成本有多少？"><a href="#问题二十：研发成本有多少？" class="headerlink" title="问题二十：研发成本有多少？"></a>问题二十：研发成本有多少？</h2><p>研发是需要成本的，愿意花费的代价是必须要思考且无法避免的问题。</p><h2 id="问题二十一：设计的电源需求是否明确？"><a href="#问题二十一：设计的电源需求是否明确？" class="headerlink" title="问题二十一：设计的电源需求是否明确？"></a>问题二十一：设计的电源需求是否明确？</h2><p>这个是一个最重要的问题，所以放到最后来说，在设计电源之初，就要把所有的需求、要求、限制都明确，并且要考虑到极限的情况，如果需求变更，需要从头来评估整体的方案，而不是在设计了一半的基础上去调整，来应对需求的变更。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EMC总结</title>
      <link href="/posts/3429177344/"/>
      <url>/posts/3429177344/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="EMC总结"><a href="#EMC总结" class="headerlink" title="EMC总结"></a>EMC总结</h2><h3 id="一、EMC标准及测试"><a href="#一、EMC标准及测试" class="headerlink" title="一、EMC标准及测试"></a>一、EMC标准及测试</h3><h4 id="国际标准"><a href="#国际标准" class="headerlink" title="国际标准"></a>国际标准</h4><p>1、国际电工委员为IEC</p><p>2、国际标准华组织ISO</p><p>3、电气电子工程师学会IEEE</p><p>4、欧盟电信标准委员会ETSI</p><p>5、国际无线电通信咨询委员CCIR</p><p>6、国际通讯联盟ITU</p><p>6、国际电工委员会IEC有以下分会进行EMC标准研究</p><p>-CISPR：国际无线电干扰特别委员会</p><p>-TC77：电气设备(包括电网)内电磁兼容技术委员会</p><p>-TC65：工业过程测量和控制</p><h4 id="国际标准化组织"><a href="#国际标准化组织" class="headerlink" title="国际标准化组织"></a>国际标准化组织</h4><p>1、FCC联邦通</p><p>2、VDE德国电气工程师协会</p><p>3、VCCI日本民间干扰</p><p>4、BS英国标准</p><p>5、ABSI美国国家标准</p><p>6、GOSTR俄罗斯政府标准</p><p>7、GB、GB/T中国国家标准</p><h4 id="EMI测试"><a href="#EMI测试" class="headerlink" title="EMI测试"></a>EMI测试</h4><p>1、辐射骚扰电磁场(RE)</p><p>2、骚扰功率(DP)</p><p>3、传导骚扰(CE)</p><p>4、谐波电路(Harmonic)</p><p>5、电压波动及闪烁(Flicker)</p><p>6、瞬态骚扰电源(TDV)</p><h4 id="EMS测试"><a href="#EMS测试" class="headerlink" title="EMS测试"></a>EMS测试</h4><p>1、辐射敏感度试验(RS)</p><p>2、工频次次辐射敏感度试验(PMS)</p><p>3、静电放电抗扰度(ESD)</p><p>4、射频场感应的传导骚扰抗扰度测试(CS)</p><p>5、电压暂降，短时中断和电压变化抗扰度测试(DIP)</p><p>6、浪涌(冲击)抗扰度测试(SURGE)</p><p>7、电快速瞬变脉冲群抗扰度测试(EFT/B)</p><p>8、电力线感应/接触(Power induction/contact)</p><h4 id="EMC测试结果的评价"><a href="#EMC测试结果的评价" class="headerlink" title="EMC测试结果的评价"></a>EMC测试结果的评价</h4><p>A级：实验中技术性能指标正常</p><p>B级：试验中性能暂时降低，功能不丧失，实验后能自行恢复</p><p>C级：功能允许丧失，但能自恢复，或操作者干预后能恢复</p><p>R级：除保护元件外，不允许出现因设备(元件)或软件损坏数据丢失而造成不能恢复的功能丧失或性能降低。</p><p>5、电压暂降，短时中断和电压变化抗扰度测试(DIP)</p><p>6、浪涌(冲击)抗扰度测试(SURGE)</p><p>7、电快速瞬变脉冲群抗扰度测试(EFT/B)</p><p>8、电力线感应/接触(Power induction/contact)</p><h3 id="二、EMC理论"><a href="#二、EMC理论" class="headerlink" title="二、EMC理论"></a>二、EMC理论</h3><h4 id="EMC理论"><a href="#EMC理论" class="headerlink" title="EMC理论"></a>EMC理论</h4><p>-电磁干扰的时域与频域描述 :时域特性</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082115.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082115.png" class="lazyload" title></a></p><p>-电磁干扰的时域与频域描述 :频域特性</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082149.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082149.png" class="lazyload" title></a></p><p>-电磁干扰的时域与频域描述 :周期梯形波的</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082212.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082212.png" class="lazyload" title></a></p><p>-电磁干扰的时域与频域描述:宽带噪声</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082241.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082241.png" class="lazyload" title></a></p><p>-电磁干扰的时域与频域描述:时钟与数据噪声</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082302.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082302.png" class="lazyload" title></a></p><p>-分贝(dB)的概念</p><p>分贝是电磁兼容中常用的基本单位。</p><p>定义为两个功率的比：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082322.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082322.png" class="lazyload" title></a></p><h3 id="三、传导干扰耦合形式"><a href="#三、传导干扰耦合形式" class="headerlink" title="三、传导干扰耦合形式"></a>三、传导干扰耦合形式</h3><h4 id="1、共阻抗耦合"><a href="#1、共阻抗耦合" class="headerlink" title="1、共阻抗耦合"></a>1、共阻抗耦合</h4><p>-由两个回路经公共阻抗耦合而产生，干扰量是电流i，或变化的电流di/dt。</p><h4 id="2、容性耦合"><a href="#2、容性耦合" class="headerlink" title="2、容性耦合"></a>2、容性耦合</h4><p>-在干扰源与干扰对称之间存在着耦合的分布电容而产生，干扰量是变化的电场，即变化的电压du/dt。</p><h4 id="3、感性耦合"><a href="#3、感性耦合" class="headerlink" title="3、感性耦合"></a>3、感性耦合</h4><p>-在干扰源与干扰对称之间存在着互感而产生，干扰量是变化的磁场，即变化的电流di/dt。</p><p>-电场与磁场</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082351.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082351.png" class="lazyload" title></a></p><p>电场：导体之间的电压产生电场</p><p>-电场强度单位：V/m</p><p>磁场：导体上的电流产生磁场</p><p>-磁场强度单位：A/m</p><p>波阻抗：Zo=E/H</p><h3 id="四、差模辐射与共模辐射"><a href="#四、差模辐射与共模辐射" class="headerlink" title="四、差模辐射与共模辐射"></a>四、差模辐射与共模辐射</h3><h4 id="1、差模辐射：电流在信号环路中流动产生"><a href="#1、差模辐射：电流在信号环路中流动产生" class="headerlink" title="1、差模辐射：电流在信号环路中流动产生"></a>1、差模辐射：电流在信号环路中流动产生</h4><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082411.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082411.png" class="lazyload" title></a></p><h4 id="2、共模辐射：由于导体的电位高于参考电位产生"><a href="#2、共模辐射：由于导体的电位高于参考电位产生" class="headerlink" title="2、共模辐射：由于导体的电位高于参考电位产生"></a>2、共模辐射：由于导体的电位高于参考电位产生</h4><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082430.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082430.png" class="lazyload" title></a></p><h4 id="3、PCB主要产生差模辐射"><a href="#3、PCB主要产生差模辐射" class="headerlink" title="3、PCB主要产生差模辐射"></a>3、PCB主要产生差模辐射</h4><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082453.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082453.png" class="lazyload" title></a></p><h4 id="4、线缆主要产生共模辐射"><a href="#4、线缆主要产生共模辐射" class="headerlink" title="4、线缆主要产生共模辐射"></a>4、线缆主要产生共模辐射</h4><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082510.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082510.png" class="lazyload" title></a></p><h4 id="5、差模辐射电场的计算"><a href="#5、差模辐射电场的计算" class="headerlink" title="5、差模辐射电场的计算"></a>5、差模辐射电场的计算</h4><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082538.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082538.png" class="lazyload" title></a></p><p>其中 ：</p><p>E:电场强度(V/m)</p><p>f :电流的频率(MHz)</p><p>A:电流的环路面积(cm2)</p><p>I :电流的强度(mA)</p><p>r :测试点到电流环路的距离(m)</p><h4 id="6、共模辐射电场的计算"><a href="#6、共模辐射电场的计算" class="headerlink" title="6、共模辐射电场的计算"></a>6、共模辐射电场的计算</h4><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082558.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082558.png" class="lazyload" title></a></p><p>其中 ：</p><p>E:电场强度(V/m)</p><p>f :电流的频率(MHz)</p><p>L:电缆的长度(m)</p><p>I :电流的强度(mA)</p><p>r :测试点到电流环路的距离(m)</p><h4 id="7、屏蔽的基本理论和设计要点"><a href="#7、屏蔽的基本理论和设计要点" class="headerlink" title="7、屏蔽的基本理论和设计要点"></a>7、屏蔽的基本理论和设计要点</h4><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082624.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082624.png" class="lazyload" title></a></p><h5 id="7-1屏蔽效能计算公式："><a href="#7-1屏蔽效能计算公式：" class="headerlink" title="7.1屏蔽效能计算公式："></a>7.1屏蔽效能计算公式：</h5><p>SE(dB)= R(dB)+A(dB)+B(dB)</p><p>R(dB)-reflection loss</p><p>A(dB)-absorption</p><p>B(dB)-re-reflection loss</p><h5 id="7-2屏蔽设计的基本原则："><a href="#7-2屏蔽设计的基本原则：" class="headerlink" title="7.2屏蔽设计的基本原则："></a>7.2屏蔽设计的基本原则：</h5><p>a、屏蔽体结构简洁，尽可能减少不必要的孔洞，尽可能不要增加额外的缝隙;</p><p>b、避免开细长孔，通风孔尽量采用圆孔并阵列排放。屏蔽和散热有矛盾时尽可能开小孔，多开孔，避免开大孔;</p><p>c、足够重视电缆的处理措施，电缆的处理往往比屏蔽本身还重要;</p><p>d、屏蔽体的电连续性是影响结构件屏蔽效能最主要的因素，相对而言，一般材料本身屏蔽性能以及材料厚度的影响是微不足道的(低频磁场例外);</p><p>e、注意控制成本;</p><h3 id="五、EMC设计"><a href="#五、EMC设计" class="headerlink" title="五、EMC设计"></a>五、EMC设计</h3><h4 id="EMC屏蔽设计"><a href="#EMC屏蔽设计" class="headerlink" title="EMC屏蔽设计"></a>EMC屏蔽设计</h4><p>1、通风孔及开口设计</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082644.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082644.png" class="lazyload" title></a></p><p>2、结构搭接缝屏蔽设计</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082711.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082711.png" class="lazyload" title></a></p><p>3、电缆从屏蔽体内穿出</p><p>如果导体从屏蔽体中穿出去，将对屏蔽体的屏蔽效能产生显著的劣化作用。这种穿透比较典型的是电缆从屏蔽体中穿出。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082732.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082732.png" class="lazyload" title></a></p><p>4、穿出屏蔽体电缆的设计原则：</p><p>a、采用屏蔽电缆时，屏蔽电缆在出屏蔽体时，采用夹线结构，保证电缆屏蔽层与屏蔽体之间可靠接地，提供足够低的接触阻抗。</p><p>b、采用屏蔽电缆时，用屏蔽连接器转接将信号接出屏蔽体，通过连接器保证电缆屏蔽层的可靠接地。</p><p>c、采用非屏蔽电缆时，采用滤波连接器转接，由于滤波器通高频的特性，保证电缆与屏蔽体之间有足够低的高频阻抗。</p><p>d、采用非屏蔽电缆时，电缆在屏蔽体的内侧(或者外侧)要足够短，使干扰信号不能有效地耦合出去，从而减小了电缆穿透的影响。</p><p>e、电源线通过电源滤波器出屏蔽体，由于滤波器通高频的特性，保证电源线与屏蔽体之间有足够低的高频阻抗。</p><p>f、采用光纤出线。由于光纤本身没有金属体，也就不存在电缆穿透的问题。</p><p>5、不良接地</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082803.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082803.png" class="lazyload" title></a></p><p>6、屏蔽材料及应用(导电布、簧片、导电橡胶)</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082828.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082828.png" class="lazyload" title></a></p><p>7、截止波导通风板</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082852.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082852.png" class="lazyload" title></a></p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082917.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019082917.png" class="lazyload" title></a></p><p><a href="https://mmbiz.qpic.cn/mmbiz_jpg/GFk2abHRMHSo3PCnNqHQplSE17qNN58QdiapekBJzjeyRteADvRXAtYO6eEd5s0UDyPX4XYkAztVFga7H0W47iag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/GFk2abHRMHSo3PCnNqHQplSE17qNN58QdiapekBJzjeyRteADvRXAtYO6eEd5s0UDyPX4XYkAztVFga7H0W47iag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" title="img"></a></p><p>8、良好接地</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083015.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083015.png" class="lazyload" title></a></p><h4 id="EMC接地设计"><a href="#EMC接地设计" class="headerlink" title="EMC接地设计"></a>EMC接地设计</h4><p>1、接地的概念及目的</p><p>a、一是为了安全，称为保护接地。电子设备的金属外壳必须接大地，这样可以避免因事故导致金属外壳上出现过高对地电压而危及操作人员和设备的安全。</p><p>b、二是为电流返回其源提供低阻抗通道，即工作接地。</p><p>c、防雷接地，为雷击提供电流泄放。</p><p>2、接地提供信号回流</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083041.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083041.png" class="lazyload" title></a></p><p>3、单点接地</p><p>适用于工作频率1MHz以下系统</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083107.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083107.png" class="lazyload" title></a></p><p>由于地线长度的原因，共模电压依然存在，所以单点接地适合工作频率不高的系统。</p><p>4、多点接地及混合接地</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083258.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083258.png" class="lazyload" title></a></p><h4 id="EMC滤波设计"><a href="#EMC滤波设计" class="headerlink" title="EMC滤波设计"></a>EMC滤波设计</h4><p>1、滤波</p><p>a、滤波电路是由电感、电容、电阻、铁氧体磁珠和共模线圈构成的频率选择性网络，阻止某段频率范围内的信号沿线传递。</p><p>b、 滤波电路种类：反射、吸收。</p><p>2、滤波器件</p><p>a、电容(通用电容、三端电容)</p><p>b、电感(通用电感、共模电感、磁珠)</p><p>c、电阻</p><p>3、基本的滤波形式</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083319.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083319.png" class="lazyload" title></a></p><p>4、差模滤波与共模滤波设计：</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083339.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083339.png" class="lazyload" title></a></p><p>5、电容和三端电容特性</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083402.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083402.png" class="lazyload" title></a></p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083427.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083427.png" class="lazyload" title></a></p><p>6、共模扼流圈</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083446.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083446.png" class="lazyload" title></a></p><p>7、铁氧体磁珠</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083505.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083505.png" class="lazyload" title></a></p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083524.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083524.png" class="lazyload" title></a></p><h4 id="EMC-PCB设计"><a href="#EMC-PCB设计" class="headerlink" title="EMC PCB设计"></a>EMC PCB设计</h4><p><strong>1、PCB设计</strong></p><p>a、布局：同类电路布在一块、控制最小路径原则、高速电路间不要靠近小面板、电源模块靠近进单盘的位置</p><p>b、分层：高速布线层必须靠近一层地、电源与地相邻、元件面下布一层地、近可能将两个表层布地层、内层比表层缩进20H</p><p>c、布线：3W原则、差分对线等长，靠近走、高速或敏感线不能 跨分割区</p><p>d、接地：同类电路单独分布地，在单板上单点相连</p><p>e、滤波：电源模块、功能电路设计板级虑波电路</p><p>f、接口电路设计：接口电路设计滤波电路、实现内外有效隔离</p><p><strong>2、布局的基本原则：</strong></p><p>a、参照原理功能框图，基于信号流向，按照功能模块划分</p><p>b、数字电路与模拟电路、高速电路与低速电路、干扰源与敏感电路分开布局</p><p>c、单板焊接面避免放置敏感器件或强辐射器件</p><p>d、敏感信号、强辐射信号回路面积最小</p><p>e、晶体、晶振、继电器、开关电源等强辐射器件或敏感器件远离单板拉手条、对外接口连接器、敏感器件放置，推荐距离≥1000mil</p><p>f、敏感器件：远离强辐射器件，推荐距离≥1000mil</p><p>g、隔离器件、A/D器件：输入、输出互相分开，无耦合通路(如相邻的参考平面)，最好跨接于对应的分割区</p><p><strong>3、特殊器件布局</strong></p><p>a、电源部分(置于电源入口处)</p><p>b、时钟部分(远离开口，靠近负载，布线内层)</p><p>c、电感线圈(远离EMI源)</p><p>d、总线驱动部分(布线内层，远离开口，靠近宿)</p><p>e、滤波器件(输入、输出分开，靠近源，引线短)</p><p><strong>4、滤波电容的布局：BULK电容：</strong></p><p>a、所有分支电源接口电路</p><p>b、功耗大的元器件附近</p><p>c、存在较大电流变化的区域，如电源模块的输入和输出端、风 扇、继电器等</p><p>d、PCB电源接口电路</p><p><strong>5、去藕电容的布局：</strong></p><p>a、靠近电源管脚</p><p>b、位置、数量适当</p><p><strong>6、接口电路的布局的基本原则：</strong></p><p>接口信号的滤波、防护和隔离等器件靠近接口连接器放置，先防护，后滤波</p><p>接口变压器、光耦等隔离器件做到初次级完全隔离</p><p>变压器对应的BOTTOM层区域尽可能没有其它器件放置</p><p>接口芯片(网口、E1/T1口、串口等)尽量靠近变压器或连接器放置</p><p><strong>7、布线</strong></p><p>走线短，不同类走线间距宽(信号及其回流线、差分线、屏蔽地线除外)，过孔少，无环路，回路面积小，无线头</p><p>有延时要求的走线，其长度符合要求</p><p>无直角，对关键信号线优先采用圆弧倒角</p><p>相邻层信号走线互相垂直或相邻层的关键信号平行布线≤1000MIL</p><p>各国产品安全和EMC认证组织</p><p>-欧美：CE</p><p>-美国：FCC&UL，NEBS</p><p>-日本：VCCI</p><p>-澳大利亚：CE</p><p>-中国：CCC</p><p>-台湾：CE</p><p>-认证申请</p><p>-提交认证材料(认证标准、产品使用手册等)</p><p>-产品测试</p><p>-完成测试报告</p><p>-颁发认证证书</p><p>-产品发布</p><h3 id="EMC工程师八个技能"><a href="#EMC工程师八个技能" class="headerlink" title="EMC工程师八个技能"></a>EMC工程师八个技能</h3><p>1、EMC的基本测试项目以及测试过程掌握;</p><p>2、产品对应EMC的标准掌握;</p><p>3、产品的EMC整改定位思路掌握;</p><p>4、产品的各种认证流程掌握;</p><p>5、产品的硬件硬件知识，对电路(主控、接口)了解;</p><p>6、EMC设计整改元器件(电容、磁珠、滤波器、电感、瞬态抑制器件等)使用掌握;</p><p>7、产品结构屏蔽设计技能掌握;</p><p>8、对EMC设计如何介入产品各个研发阶段流程掌握。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> EMC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> EMC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传感器3种常用算法处理</title>
      <link href="/posts/3384778559/"/>
      <url>/posts/3384778559/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="传感器3种常用算法处理"><a href="#传感器3种常用算法处理" class="headerlink" title="传感器3种常用算法处理"></a>传感器3种常用算法处理</h3><p>在传感器使用中，我们常常需要对传感器数据进行各种整理，让应用获得更好的效果，以下介绍几种常用的简单处理方法：</p><p>1.加权平滑：平滑和均衡传感器数据，减小偶然数据突变的影响;</p><p>2.抽取突变：去除静态和缓慢变化的数据背景，强调瞬间变化;</p><p>3.简单移动平均线：保留数据流最近的K个数据，取平均值;</p><h4 id="一、加权平滑"><a href="#一、加权平滑" class="headerlink" title="一、加权平滑"></a>一、加权平滑</h4><p><strong>加权平滑</strong>，使用算法如下：</p><p>(新值) = (旧值)*(1 - a) + X * a其中a为设置的权值，X为最新数据，程序实现如下：</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float ALPHA = 0.1f;</span><br><span class="line">void onSensorChanged(SensorEvent event){</span><br><span class="line">x = event.values[0];</span><br><span class="line">y = event.values[1];</span><br><span class="line">z = event.values[2];</span><br><span class="line">mLowPassX = lowPass(x,mLowPassX);</span><br><span class="line">mLowPassY = lowPass(x,mLowPassY);</span><br><span class="line">mLowPassZ = lowPass(x,mLowPassZ);</span><br><span class="line">}</span><br><span class="line">float lowPass(float current,float last){</span><br><span class="line">return last * (1.0f - ALPHA) + current * ALPHA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="二、抽取突变"><a href="#二、抽取突变" class="headerlink" title="二、抽取突变"></a>二、抽取突变</h4><p><strong>抽取突变采用上面加权平滑的逆算法</strong></p><p>实现代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float ALPHA = 0.1f;</span><br><span class="line">public void onSensorChanged(SensorEvent event){</span><br><span class="line">    x = event.values[0];</span><br><span class="line">    y = event.values[1];</span><br><span class="line">    z = event.values[2];</span><br><span class="line">    mLowPassX = lowPass(x,mLowPassX);</span><br><span class="line">    mLowPassY = lowPass(x,mLowPassY);</span><br><span class="line">    mLowPassZ = lowPass(x,mLowPassZ);</span><br><span class="line">}</span><br><span class="line">private float lowPass(float current,float last){</span><br><span class="line">return last * (1.0f - ALPHA) + current * ALPHA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="三、简单移动平均线"><a href="#三、简单移动平均线" class="headerlink" title="三、简单移动平均线"></a>三、简单移动平均线</h4><p>保留传感器数据流中最近的K个数据，返回它们的平均值。k表示平均“窗口”的大小；</p><p>实现代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class MovingAverage{</span><br><span class="line">    private float circularBuffer[]; //保存传感器最近的K个数据</span><br><span class="line">    private float avg; //返回到传感器平均值</span><br><span class="line">    private float sum; //数值中传感器数据的和</span><br><span class="line">    private float circularIndex; //传感器数据数组节点位置</span><br><span class="line">    private int count;public MovingAverage(int k){</span><br><span class="line">    circularBuffer = new float[k];</span><br><span class="line">    count= 0;</span><br><span class="line">    circularIndex = 0;</span><br><span class="line">    avg = 0;</span><br><span class="line">    sum = 0;</span><br><span class="line">}</span><br><span class="line">    public float getValue(){</span><br><span class="line">        return arg;</span><br><span class="line">    }</span><br><span class="line">    public long getCount(){</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line">    private void primeBuffer(float val){</span><br><span class="line">        for(int i=0;i<circularbuffer.length;++i){< span><br><span class="line">            circularBuffer[i] = val;</span><br><span class="line">            sum += val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    private int nextIndex(int curIndex){</span><br><span class="line">        if(curIndex + 1 >= circularBuffer.length){</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line">        return curIndex + 1;</span><br><span class="line">    }</span><br><span class="line">    public void pushValue(float x){</span><br><span class="line">        if(0 == count++){</span><br><span class="line">            primeBuffer(x);</span><br><span class="line">        }</span><br><span class="line">        float lastValue = circularBuffer[circularIndex];</span><br><span class="line">        circularBuffer[circularIndex] = x; //更新窗口中传感器数据</span><br><span class="line">        sum -= lastValue; //更新窗口中传感器数据和</span><br><span class="line">        sum += x;</span><br><span class="line">        avg = sum / circularBuffer.length; //计算得传感器平均值</span><br><span class="line">        circularIndex = nextIndex(circularIndex);</span><br><span class="line">}</span><br><span class="line">}</span><br></circularbuffer.length;++i){<></span></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EMC（电磁兼容性）</title>
      <link href="/posts/402795366/"/>
      <url>/posts/402795366/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>电磁兼容性EMC是指设备或系统在其电磁环境中能正常工作且不对该环境中任何事物构成不能承受电磁骚扰的能力。传感器电磁兼容性是指传感器在电磁环境中的适应性，保持其固有性能、完成规定功能的能力。它包含两个方面要求：一方面要求传感器在正常运行过程中对所在环境产生电磁干扰不能超过一定限值;另一方面要求传感器对所在环境中存在电磁干扰具有一定程度抗扰度。</p><p>电磁兼容是研究在有限的空间、时间、频谱资源条件下，各种用电设备（广义还包括生物体）可以共存，并不致引起降级的一门学科。它包括电磁干扰和电磁敏感度两部分，电磁干扰测试是测量被测设备在正常工作状态下产生并向外发射的电磁波信号的大小来反应对周围电子设备干扰的强弱。电磁敏感度测试是测量被测设备对电磁骚扰的抗干扰的能力强弱 。</p><h2 id="电磁兼容测试项目"><a href="#电磁兼容测试项目" class="headerlink" title="电磁兼容测试项目"></a>电磁兼容测试项目</h2><p>传导conduction emission （9kHz-30MHz）<br>功率辐射power clamp （30MHz-300MHz）<br>磁场辐射magnetic emission（9kHz-30MHz）<br>空间辐射radiated emission（30MHz-18GHz）<br>断续传导干扰click<br>谐波harmonics class a,b ,c,d<br>电压闪烁flicker plt .pst<br>静电ESD （±0.1-±16.5kV）<br>辐射抗扰度（1GHz以下）<br>快速脉冲群EFT/B （±0.1-±4.4kV）<br>浪涌surge （0.1-6.6kV）<br>传导抗扰度CS（0.1-30V）<br>抗磁场干扰MS（0-120A/m）<br>断电Dips（0%-100%）<br>振荡波浪涌 Oscillatory Waves Surge 0.1-6.6kV 波形100kHz<br>谐波、谐间波抗干扰 Harmonic、interharmonic immunity<br>磁场EFM 10Hz-400kHz （EN50366）</p><h2 id="EMC技术的国家标准（电磁兼容国标、EMC国标）"><a href="#EMC技术的国家标准（电磁兼容国标、EMC国标）" class="headerlink" title="EMC技术的国家标准（电磁兼容国标、EMC国标）"></a>EMC技术的国家标准（电磁兼容国标、EMC国标）</h2><h3 id="基础类标准"><a href="#基础类标准" class="headerlink" title="基础类标准"></a>基础类标准</h3><p>GB/T 4365–2003 电磁兼容术语<br>GB/T 6113–2018 无线电干扰和抗扰度测量设备规范<br>GB/T 15658–2012 无线电噪声测量方法</p><h3 id="通用类标准"><a href="#通用类标准" class="headerlink" title="通用类标准"></a>通用类标准</h3><p>GB 8702–2014 电磁环境控制限值<br>GB/T 17626.1-2006 电磁兼容 试验和测量技术 抗扰度试验总论<br>GB/T 17626.2-2018 电磁兼容 试验和测量技术 静电放电抗扰度试验<br>GB/T 17626.3-2016 电磁兼容 试验和测量技术 射频电磁场辐射抗扰度试验<br>GB/T 17626.4-2018 电磁兼容 试验和测量技术 电快速瞬变脉冲群抗扰度试验<br>GB/T 17626.5-2008 电磁兼容.试验和测量技术.浪涌(冲击)抗扰度试验<br>GB/T 17626.5-2019 电磁兼容 试验和测量技术 浪涌（冲击）抗扰度试验<br>GB/T 17626.6-2017 电磁兼容 试验和测量技术 射频场感应的传导骚扰抗扰度<br>GB/T 17626.7-2017 电磁兼容 试验和测量技术 供电系统及所连设备谐波、间谐波的测量和测量仪器导则<br>GB/T 17626.8-2006 电磁兼容 试验和测量技术 工频磁场抗扰度试验<br>GB/T 17626.9-2011 电磁兼容.试验和测量技术.脉冲磁场抗扰度试验<br>GB/T 17626.10-2017 电磁兼容 试验和测量技术 阻尼振荡磁场抗扰度试验<br>GB/T 17626.11-2008 电磁兼容.试验和测量技术.电压暂降、短时中断和电压变化的抗扰度试验<br>GB/T 17626.13-2006 电磁兼容 试验和测量技术 交流电源端口谐波、谐间波及电网信号的低频抗扰度试验<br>GB/T 17626.14-2005 电磁兼容 试验和测量技术 电压波动抗扰度试验<br>GB/T 17626.15-2011 电磁兼容.试验和测量技术.闪烁仪功能和设计规范<br>GB/T 17626.16-2007 电磁兼容 试验和测量技术 OHz～150kHz共模传导骚扰抗扰度试验<br>GB/T 17626.17-2005 电磁兼容 试验和测量技术 直流电源输入端口纹波抗扰度试验<br>GB/T 17626.18-2016 电磁兼容 试验和测量技术 阻尼振荡波抗扰度试验<br>GB/T 17626.20-2014 电磁兼容 试验和测量技术 横电磁波(TEM)波导中的发射和抗扰度试验<br>GB/T 17626.21-2014 电磁兼容 试验和测量技术 混波室试验方法<br>GB/T 17626.22-2017 电磁兼容 试验和测量技术 全电波暗室中的辐射发射和抗扰度测量<br>GB/T 17626.24-2012 电磁兼容.试验和测量技术.HEMP传导骚扰保护装置的试验方法<br>GB/T 17626.27-2006 电磁兼容 试验和测量技术 三相电压不平衡抗扰度试验<br>GB/T 17626.28-2006 电磁兼容 试验和测量技术 工频频率变化抗扰度试验<br>GB/T 17626.29-2006 电磁兼容 试验和测量技术 直流电源输入端口电压暂降、短时中断和电压变化的抗扰度试验<br>GB/T 17626.30-2012 电磁兼容.试验和测量技术.电能质量测量方法<br>GB/T 17626.34-2012 电磁兼容.试验和测量技术.主电源每相电流大于16A的设备的电压暂降、短时中断和电压变化抗扰度试验<br>GB/T 14431–1993 无线电业务要求的信号/干扰保护比和最小可用场强</p><p>注：标准参考更新与2019.07</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> EMC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> EMC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用EN脚设计出好电源？</title>
      <link href="/posts/292085883/"/>
      <url>/posts/292085883/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><a href="https://mmbiz.qpic.cn/mmbiz_jpg/1icDErpg0aYs6VQS9NibsVZJpKibSJAibwxGuUwoVibKtmcibG3HVMrfgibokzRm8YNvzsIBsibIwuX7ibFANQRMib2whWJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/1icDErpg0aYs6VQS9NibsVZJpKibSJAibwxGuUwoVibKtmcibG3HVMrfgibokzRm8YNvzsIBsibIwuX7ibFANQRMib2whWJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" title="img"></a> <strong>以ZL6205为例，先简单介绍一下</strong></p><p>致远微电子推出的ZL6205系列LDO，具有低压差(240mV@500mA)，较好的输出电压精度（±1%），较大的负载电流特性，同时集成欠压，过流，短路，过温等保护功能。同样ZL6205也带EN脚，下文就以ZL6205为例，结合ZL6205内部集成的快速放电电路，举例说明EN脚在最常见的两种使能方式下对输出产生的不同效果。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083713.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083713.png" class="lazyload" title></a></p><p>图1 ZL6205引脚信息</p><p>在了解EN脚不同使能方式之前，有必要了解下ZL6205的一些电气特性。表1为ZL6205数据手册里的部分电气参数。VUVLO为ZL6205的欠压关断阈值电压，小于这个电压值，芯片处于关闭状态，REN为内部集成的下拉电阻，EN悬空时内部拉为低电平。EN引脚为高电平使能引脚，在推荐的工作电压范围内，VHI和VLO分别为可靠识别的高电平（≥1.8V）和低电平（≤0.4V）。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083730.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083730.png" class="lazyload" title></a></p><p>表1 相关电气参数</p><p>但是表1中的VHI和VLO不是实际的使能电压阈值，图2的曲线才是ZL6205的在不同输入电压下的实际使能电压阈值，可以看到随着ZL6205输入电压的升高，使能电压阈值会跟着升高，但ZL6205的使能电压阈值的回滞电压很小。例如ZL6205在VIN=4.2V的时候，VEN=1.2V是上电时的使能电压阈值，也是掉电时的禁能电压阈值。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083750.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083750.png" class="lazyload" title></a></p><p>图2 EN使能阈值与输入电压的关系</p><p><a href="https://mmbiz.qpic.cn/mmbiz_jpg/1icDErpg0aYs6VQS9NibsVZJpKibSJAibwxGuUwoVibKtmcibG3HVMrfgibokzRm8YNvzsIBsibIwuX7ibFANQRMib2whWJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/1icDErpg0aYs6VQS9NibsVZJpKibSJAibwxGuUwoVibKtmcibG3HVMrfgibokzRm8YNvzsIBsibIwuX7ibFANQRMib2whWJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" title="img"></a> <strong>直接上拉使能</strong></p><p>图3为电源常见的使能方式，EN脚与VIN脚直接短接。当ZL6205上电时，VEN始终VIN相等，有时候VIN与EN脚间串联一个电阻（常见的数k到数十k），但通常EN引脚的输入阻抗较大，ZL6205的REN的阻值为3MΩ，所以EN脚电压信号还是会与VIN基本保持一致。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083807.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083807.png" class="lazyload" title></a></p><p>图3 直接上拉使能</p><p>按照上图的电路设计，ZL6205在轻载时上下电会得到图4这样的输入输出电压曲线。<strong>这个电路的最大特点就是上下电过程中，输出的开启和关闭完全由芯片固有的欠压阈值VUVLO（2.1V）控制，而不受VEN（EN脚的逻辑阈值电压）控制。</strong>各个时间段特点如表2所示。上下电过程中输入电压越过VUVLO后均有一段输出跟随输入电压的阶段（t1<del>t2，t3</del>t4），该电路比较适合输入电压较为稳定，且对输出电压上下电速度要求不高的场合。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083827.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083827.png" class="lazyload" title></a></p><p>表2 各段时间电压特征说明</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083846.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083846.png" class="lazyload" title></a></p><p>图4 直接上拉使能输入输出电压曲线</p><p><a href="https://mmbiz.qpic.cn/mmbiz_jpg/1icDErpg0aYs6VQS9NibsVZJpKibSJAibwxGuUwoVibKtmcibG3HVMrfgibokzRm8YNvzsIBsibIwuX7ibFANQRMib2whWJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/1icDErpg0aYs6VQS9NibsVZJpKibSJAibwxGuUwoVibKtmcibG3HVMrfgibokzRm8YNvzsIBsibIwuX7ibFANQRMib2whWJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" title="img"></a> <strong>电阻分压使能</strong></p><p>有时候需要VIN上升或者跌落到某一电压（不小于VUVLO）后，才允许ZL6205启动输出电压或者关闭输出电压，这样就需要图5这样的使能电路。根据图2可知，ZL6205在VIN=2.2V~6.5V的输入电压范围内的使能电压阈值VEN=1.2V±0.3V，这样就可以通过电阻分压来设置ZL6205的上电时的启动电压（或掉电时的关闭电压）。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083846.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083846.png" class="lazyload" title></a></p><p>图5 电阻分压使能</p><p>根据图5可以得到以下公式。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083924.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083924.png" class="lazyload" title></a></p><p>VEN_SD：上电过程中期望的开启电压点（或者掉电过程中期望的关闭电压点），该值需要大于VUVLO（2.1V），小于VIN。</p><p>VEN：VEN_SD电压对应的器件实际使能阈值（可以根据图2得到），要求精度不高时，可以统一按照1.2V来计算。</p><p>例如，对于常用的3.3V输出版本的ZL6205来说，在电源上下电过程中，希望达到一定的电压值，例如3.6V，再开启或者关闭ZL6205。那么这个3.6V就是需要设定的电压点VEN_SD。根据图2可知，输入电压为3.6V对应的VEN为1.15V。代入上面的公式得R1：R2=2.13， 电阻R1和R2需要满足这个比例，结合考虑功耗，稳定性和EN输入阻抗，推荐R1=100k，R2 = 47k。</p><p>按照上面设计，ZL6205上下电会得到图6这样的输入输出电压曲线。对于常用的3.3V输出版本的ZL6205来说，3.6V的VEN_SD能满足全负载范围的压差VDROP需要。各个时间段特点如表3所示。<strong>这个电路的最大特点就是上下电过程中，输出的开启和关闭完全由设定的VEN_SD来控制，而不受芯片的欠压阈值VUVLO（2.1V）控制。当设置的VEN_SD大于稳态输出电压VOUT时，上下电过程很快，看起来几乎是一步到位，而没有输出跟随输入电压的阶段，在输入电压低于VEN_SD的阶段无论输入怎么波动都不会影响到输出。</strong>所以该电路在输入电压上下电缓慢且不稳定的场合中使用，输出可以获得更加快速且稳定的上下电效果。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083941.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019083941.png" class="lazyload" title></a></p><p>表3 各段时间电压特征说明</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019084002.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019084002.png" class="lazyload" title></a></p><p>图6 电阻分压使能输入输出电压曲线</p><p><a href="https://mmbiz.qpic.cn/mmbiz_jpg/1icDErpg0aYs6VQS9NibsVZJpKibSJAibwxGuUwoVibKtmcibG3HVMrfgibokzRm8YNvzsIBsibIwuX7ibFANQRMib2whWJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/1icDErpg0aYs6VQS9NibsVZJpKibSJAibwxGuUwoVibKtmcibG3HVMrfgibokzRm8YNvzsIBsibIwuX7ibFANQRMib2whWJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" title="img"></a> <strong>其他使能的应用</strong></p><p>对于电源来说，利用EN脚控制输出的方式还有很多。如图7所示，该电路可以通过调整RC参数（R1和C4，R2和C8）来调整输出上下电时序，也可以通过外部控制信号POWER_EN1和POWER_EN2来控制输出电压上下电时序。图8则是利用第一路的输出VOUT1作为输入信号来控制第二路的输出VOUT2，从而实现需要的上电时序。</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019084021.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019084021.png" class="lazyload" title></a></p><p>图7 输出电压时序应用电路一</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019084038.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/20201019084038.png" class="lazyload" title></a></p><p>图8 输出电压时序应用电路二</p><p><a href="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://cdn.jsdelivr.net/gh/zpolte/data/img/ymz.png" class="lazyload" title></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
          <category> 电源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 电源 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
